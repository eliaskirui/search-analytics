import*as e from"@babel/types";var t="default"in e?e.default:e;var n={};Object.defineProperty(n,"__esModule",{value:true});var s=t;function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);e&&Object.keys(e).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,s.get?s:{enumerable:true,get:function(){return e[n]}})}}));t.default=e;return Object.freeze(t)}var i=_interopNamespace(s);function willPathCastToBoolean(e){const t=e;const{node:n,parentPath:s}=t;if(s.isLogicalExpression()){const{operator:e,right:t}=s.node;if("&&"===e||"||"===e||"??"===e&&n===t)return willPathCastToBoolean(s)}if(s.isSequenceExpression()){const{expressions:e}=s.node;return e[e.length-1]!==n||willPathCastToBoolean(s)}return s.isConditional({test:n})||s.isUnaryExpression({operator:"!"})||s.isLoop({test:n})}const{LOGICAL_OPERATORS:o,arrowFunctionExpression:r,assignmentExpression:a,binaryExpression:l,booleanLiteral:p,callExpression:c,cloneNode:d,conditionalExpression:u,identifier:h,isMemberExpression:m,isOptionalCallExpression:f,isOptionalMemberExpression:b,isUpdateExpression:g,logicalExpression:E,memberExpression:x,nullLiteral:O,optionalCallExpression:P,optionalMemberExpression:W,sequenceExpression:y,updateExpression:C}=i;class AssignmentMemoiser{constructor(){this._map=void 0;this._map=new WeakMap}has(e){return this._map.has(e)}get(e){if(!this.has(e))return;const t=this._map.get(e);const{value:n}=t;t.count--;return 0===t.count?a("=",n,e):n}set(e,t,n){return this._map.set(e,{count:n,value:t})}}function toNonOptional(e,t){const{node:n}=e;if(b(n))return x(t,n.property,n.computed);if(e.isOptionalCallExpression()){const n=e.get("callee");if(e.node.optional&&n.isOptionalMemberExpression()){const s=n.node.object;const i=e.scope.maybeGenerateMemoised(s);n.get("object").replaceWith(a("=",i,s));return c(x(t,h("call")),[i,...e.node.arguments])}return c(t,e.node.arguments)}return e.node}function isInDetachedTree(e){while(e){if(e.isProgram())break;const{parentPath:t,container:n,listKey:s}=e;const i=t.node;if(s){if(n!==i[s])return true}else if(n!==i)return true;e=t}return false}const j={memoise(){},handle(e,t){const{node:n,parent:s,parentPath:i,scope:o}=e;if(e.isOptionalMemberExpression()){if(isInDetachedTree(e))return;const g=e.find((({node:t,parent:n})=>b(n)?n.optional||n.object!==t:!f(n)||(t!==e.node&&n.optional||n.callee!==t)));if(o.path.isPattern()){g.replaceWith(c(r([],g.node),[]));return}const x=willPathCastToBoolean(g);const y=g.parentPath;if(y.isUpdateExpression({argument:n}))throw e.buildCodeFrameError("can't handle update expression");const C=y.isAssignmentExpression({left:g.node});const j=y.isUnaryExpression({operator:"delete"});if(j&&g.isOptionalMemberExpression()&&g.get("property").isPrivateName())throw e.buildCodeFrameError("can't delete a private class element");let M=e;for(;;)if(M.isOptionalMemberExpression()){if(M.node.optional)break;M=M.get("object")}else{if(!M.isOptionalCallExpression())throw new Error(`Internal error: unexpected ${M.node.type}`);if(M.node.optional)break;M=M.get("callee")}const v=M.isOptionalMemberExpression()?M.node.object:M.node.callee;const A=o.maybeGenerateMemoised(v);const _=null!=A?A:v;const w=i.isOptionalCallExpression({callee:n});const isOptionalCall=e=>w;const N=i.isCallExpression({callee:n});M.replaceWith(toNonOptional(M,_));isOptionalCall()?s.optional?i.replaceWith(this.optionalCall(e,s.arguments)):i.replaceWith(this.call(e,s.arguments)):N?e.replaceWith(this.boundGet(e)):this.delete&&i.isUnaryExpression({operator:"delete"})?i.replaceWith(this.delete(e)):i.isAssignmentExpression()?handleAssignment(this,e,i):e.replaceWith(this.get(e));let T=e.node;for(let t=e;t!==g;){const e=t.parentPath;if(e===g&&isOptionalCall()&&s.optional){T=e.node;break}T=toNonOptional(e,T);t=e}let U;const S=g.parentPath;if(m(T)&&S.isOptionalCallExpression({callee:g.node,optional:true})){const{object:t}=T;U=e.scope.maybeGenerateMemoised(t);U&&(T.object=a("=",U,t))}let k=g;if(j||C){k=S;T=S.node}const B=A?a("=",d(_),d(v)):d(_);if(x){let e;e=t?l("!=",B,O()):E("&&",l("!==",B,O()),l("!==",d(_),o.buildUndefinedNode()));k.replaceWith(E("&&",e,T))}else{let e;e=t?l("==",B,O()):E("||",l("===",B,O()),l("===",d(_),o.buildUndefinedNode()));k.replaceWith(u(e,j?p(true):o.buildUndefinedNode(),T))}if(U){const e=S.node;S.replaceWith(P(W(e.callee,h("call"),false,true),[d(U),...e.arguments],false))}}else{if(g(s,{argument:n})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:t,prefix:r}=s;this.memoise(e,2);const l=o.generateUidIdentifierBasedOnNode(n);o.push({id:l});const p=[a("=",d(l),this.get(e))];if(r){p.push(C(t,d(l),r));const n=y(p);i.replaceWith(this.set(e,n));return}{const s=o.generateUidIdentifierBasedOnNode(n);o.push({id:s});p.push(a("=",d(s),C(t,d(l),r)),d(l));const c=y(p);i.replaceWith(y([this.set(e,c),d(s)]));return}}if(i.isAssignmentExpression({left:n}))handleAssignment(this,e,i);else if(i.isCallExpression({callee:n}))i.replaceWith(this.call(e,i.node.arguments));else if(i.isOptionalCallExpression({callee:n})){if(o.path.isPattern()){i.replaceWith(c(r([],i.node),[]));return}i.replaceWith(this.optionalCall(e,i.node.arguments))}else this.delete&&i.isUnaryExpression({operator:"delete"})?i.replaceWith(this.delete(e)):i.isForXStatement({left:n})||i.isObjectProperty({value:n})&&i.parentPath.isObjectPattern()||i.isAssignmentPattern({left:n})&&i.parentPath.isObjectProperty({value:s})&&i.parentPath.parentPath.isObjectPattern()||i.isArrayPattern()||i.isAssignmentPattern({left:n})&&i.parentPath.isArrayPattern()||i.isRestElement()?e.replaceWith(this.destructureSet(e)):i.isTaggedTemplateExpression()?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e))}}};function handleAssignment(e,t,n){if(e.simpleSet){t.replaceWith(e.simpleSet(t));return}const{operator:s,right:i}=n.node;if("="===s)n.replaceWith(e.set(t,i));else{const r=s.slice(0,-1);if(o.includes(r)){e.memoise(t,1);n.replaceWith(E(r,e.get(t),e.set(t,i)))}else{e.memoise(t,2);n.replaceWith(e.set(t,l(r,e.get(t),i)))}}}function memberExpressionToFunctions(e,t,n){e.traverse(t,Object.assign({},j,n,{memoiser:new AssignmentMemoiser}))}n.default=memberExpressionToFunctions;const M=n.__esModule;export{M as __esModule,n as default};

