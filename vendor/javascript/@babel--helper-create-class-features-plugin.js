import*as e from"@babel/core";import*as t from"@babel/helper-function-name";import*as s from"@babel/helper-split-export-declaration";import*as n from"@babel/helper-replace-supers";import*as r from"@babel/helper-skip-transparent-expression-wrappers";import*as o from"semver";import*as i from"@babel/helper-environment-visitor";import*as a from"@babel/helper-member-expression-to-functions";import*as l from"@babel/helper-optimise-call-expression";import*as d from"@babel/helper-annotate-as-pure";var c=e;try{"default"in e&&(c=e.default)}catch(e){}var p=n;try{"default"in n&&(p=n.default)}catch(e){}var u=s;try{"default"in s&&(u=s.default)}catch(e){}var f=r;try{"default"in r&&(f=r.default)}catch(e){}var y={};Object.defineProperty(y,"__esModule",{value:true});y.default=_default;var m=c;var h=p;var b=u;var v=f;function incrementId(e,t=e.length-1){if(t===-1){e.unshift(65);return}const s=e[t];if(s===90)e[t]=97;else if(s===122){e[t]=65;incrementId(e,t-1)}else e[t]=s+1}function createPrivateUidGeneratorForClass(e){const t=[];const s=new Set;e.traverse({PrivateName(e){s.add(e.node.id.name)}});return()=>{let e;do{incrementId(t);e=String.fromCharCode(...t)}while(s.has(e));return m.types.privateName(m.types.identifier(e))}}function createLazyPrivateUidGeneratorForClass(e){let t;return()=>{t||(t=createPrivateUidGeneratorForClass(e));return t()}}function replaceClassWithVar(e,t){if(e.type==="ClassDeclaration"){const t=e.node.id;const s=t.name;const n=e.scope.generateUidIdentifierBasedOnNode(t);const r=m.types.identifier(s);e.scope.rename(s,n.name);e.get("id").replaceWith(r);return{id:m.types.cloneNode(n),path:e}}{let s;if(e.node.id){t=e.node.id.name;s=e.scope.parent.generateDeclaredUidIdentifier(t);e.scope.rename(t,s.name)}else s=e.scope.parent.generateDeclaredUidIdentifier(typeof t==="string"?t:"decorated_class");const n=m.types.classExpression(typeof t==="string"?m.types.identifier(t):null,e.node.superClass,e.node.body);const[r]=e.replaceWith(m.types.sequenceExpression([n,s]));return{id:m.types.cloneNode(s),path:r.get("expressions.0")}}}function generateClassProperty(e,t,s){return e.type==="PrivateName"?m.types.classPrivateProperty(e,t,void 0,s):m.types.classProperty(e,t,void 0,void 0,s)}function addProxyAccessorsFor(e,t,s,n,r,o=false){const{static:i}=t.node;const a=r==="2023-05"&&i?e:m.types.thisExpression();const l=m.types.blockStatement([m.types.returnStatement(m.types.memberExpression(m.types.cloneNode(a),m.types.cloneNode(n)))]);const d=m.types.blockStatement([m.types.expressionStatement(m.types.assignmentExpression("=",m.types.memberExpression(m.types.cloneNode(a),m.types.cloneNode(n)),m.types.identifier("v")))]);let c,p;if(s.type==="PrivateName"){c=m.types.classPrivateMethod("get",m.types.cloneNode(s),[],l,i);p=m.types.classPrivateMethod("set",m.types.cloneNode(s),[m.types.identifier("v")],d,i)}else{c=m.types.classMethod("get",m.types.cloneNode(s),[],l,o,i);p=m.types.classMethod("set",m.types.cloneNode(s),[m.types.identifier("v")],d,o,i)}t.insertAfter(p);t.insertAfter(c)}function extractProxyAccessorsFor(e,t){return t!=="2023-05"&&t!=="2023-01"?[m.template.expression.ast`
        function () {
          return this.${m.types.cloneNode(e)};
        }
      `,m.template.expression.ast`
        function (value) {
          this.${m.types.cloneNode(e)} = value;
        }
      `]:[m.template.expression.ast`
      o => o.${m.types.cloneNode(e)}
    `,m.template.expression.ast`
      (o, v) => o.${m.types.cloneNode(e)} = v
    `]}const g=0;const P=1;const x=2;const E=3;const C=4;const N=5;const k=8;const S=16;function getElementKind(e){switch(e.node.type){case"ClassProperty":case"ClassPrivateProperty":return g;case"ClassAccessorProperty":return P;case"ClassMethod":case"ClassPrivateMethod":return e.node.kind==="get"?E:e.node.kind==="set"?C:x}}function isDecoratorInfo(e){return"decorators"in e}function filteredOrderedDecoratorInfo(e){const t=e.filter(isDecoratorInfo);return[...t.filter((e=>e.isStatic&&e.kind>=P&&e.kind<=C)),...t.filter((e=>!e.isStatic&&e.kind>=P&&e.kind<=C)),...t.filter((e=>e.isStatic&&e.kind===g)),...t.filter((e=>!e.isStatic&&e.kind===g))]}function generateDecorationList(e,t,s){const n=e.length;const r=t.some(Boolean);const o=[];for(let i=0;i<n;i++){s==="2023-05"&&r&&o.push(t[i]||m.types.unaryExpression("void",m.types.numericLiteral(0)));o.push(e[i])}return{hasThis:r,decs:o}}function generateDecorationExprs(e,t){return m.types.arrayExpression(filteredOrderedDecoratorInfo(e).map((e=>{const{decs:s,hasThis:n}=generateDecorationList(e.decorators,e.decoratorsThis,t);let r=e.kind;e.isStatic&&(r+=t==="2023-05"?k:N);n&&(r+=S);return m.types.arrayExpression([s.length===1?s[0]:m.types.arrayExpression(s),m.types.numericLiteral(r),e.name,...e.privateMethods||[]])})))}function extractElementLocalAssignments(e){const t=[];for(const s of filteredOrderedDecoratorInfo(e)){const{locals:e}=s;Array.isArray(e)?t.push(...e):e!==void 0&&t.push(e)}return t}function addCallAccessorsFor(e,t,s,n){e.insertAfter(m.types.classPrivateMethod("get",m.types.cloneNode(t),[],m.types.blockStatement([m.types.returnStatement(m.types.callExpression(m.types.cloneNode(s),[m.types.thisExpression()]))])));e.insertAfter(m.types.classPrivateMethod("set",m.types.cloneNode(t),[m.types.identifier("v")],m.types.blockStatement([m.types.expressionStatement(m.types.callExpression(m.types.cloneNode(n),[m.types.thisExpression(),m.types.identifier("v")]))])))}function isNotTsParameter(e){return e.type!=="TSParameterProperty"}function movePrivateAccessor(e,t,s,n){let r;let o;if(e.node.kind==="set"){r=[m.types.identifier("v")];o=[m.types.expressionStatement(m.types.callExpression(s,[m.types.thisExpression(),m.types.identifier("v")]))]}else{r=[];o=[m.types.returnStatement(m.types.callExpression(s,[m.types.thisExpression()]))]}e.replaceWith(m.types.classPrivateMethod(e.node.kind,m.types.cloneNode(t),r,m.types.blockStatement(o),n))}function isClassDecoratableElementPath(e){const{type:t}=e;return t!=="TSDeclareMethod"&&t!=="TSIndexSignature"&&t!=="StaticBlock"}function staticBlockToIIFE(e){return m.types.callExpression(m.types.arrowFunctionExpression([],m.types.blockStatement(e.body)),[])}function maybeSequenceExpression(e){return e.length===0?m.types.unaryExpression("void",m.types.numericLiteral(0)):e.length===1?e[0]:m.types.sequenceExpression(e)}function createSetFunctionNameCall(e,t){return m.types.callExpression(e.addHelper("setFunctionName"),[m.types.thisExpression(),t])}function createToPropertyKeyCall(e,t){return m.types.callExpression(e.addHelper("toPropertyKey"),[t])}function transformClass(e,t,s,n,r,o){const i=e.get("body.body");const a=e.node.decorators;let l=false;const d=createLazyPrivateUidGeneratorForClass(e);const c=[];const p=e.scope.parent;const memoiseExpression=(e,t)=>{const s=p.generateDeclaredUidIdentifier(t);c.push(m.types.assignmentExpression("=",s,e));return m.types.cloneNode(s)};for(const s of i)if(isClassDecoratableElementPath(s))if(s.node.decorators&&s.node.decorators.length>0){switch(s.node.type){case"ClassProperty":o.ClassProperty(s,t);break;case"ClassPrivateProperty":o.ClassPrivateProperty(s,t);break;case"ClassAccessorProperty":o.ClassAccessorProperty(s,t);break}l=true}else if(s.node.type==="ClassAccessorProperty"){o.ClassAccessorProperty(s,t);const{key:r,value:i,static:a,computed:l}=s.node;const c=d();const p=generateClassProperty(c,i,a);const u=s.get("key");const[f]=s.replaceWith(p);addProxyAccessorsFor(e.node.id,f,l&&!u.isConstantExpression()?memoiseExpression(createToPropertyKeyCall(t,r),"computedKey"):r,c,n,l)}if(!a&&!l){if(c.length>0){e.insertBefore(c.map((e=>m.types.expressionStatement(e))));e.scope.crawl()}return}const u=[];let f;let y;let b=false;let v=false;const x=new Set;let N,k,S,I;const F=new Map;const maybeExtractDecorator=e=>{const{expression:t}=e;if(n==="2023-05"&&m.types.isMemberExpression(t)){let s;if(m.types.isSuper(t.object)||m.types.isThisExpression(t.object))s=memoiseExpression(m.types.thisExpression(),"obj");else if(p.isStatic(t.object))s=t.object;else{s=memoiseExpression(t.object,"obj");t.object=s}F.set(e,m.types.cloneNode(s))}p.isStatic(t)||(e.expression=memoiseExpression(t,"dec"))};let D=false;if(a){S=p.generateDeclaredUidIdentifier("initClass");D=e.isClassDeclaration();({id:I,path:e}=replaceClassWithVar(e,r));e.node.decorators=null;for(const e of a)maybeExtractDecorator(e)}else{e.node.id||(e.node.id=e.scope.generateUidIdentifier("Class"));I=m.types.cloneNode(e.node.id)}let $;let w=false;if(l)for(const r of i){if(!isClassDecoratableElementPath(r))continue;const{node:o}=r;const i=r.get("decorators");const a=Array.isArray(i)&&i.length>0;if(a)for(const e of i)maybeExtractDecorator(e.node);const l="computed"in r.node&&r.node.computed===true;l&&(r.get("key").isConstantExpression()||(o.key=memoiseExpression(createToPropertyKeyCall(t,o.key),"computedKey")));const c=getElementKind(r);const{key:p}=o;const N=p.type==="PrivateName";const k=!!r.node.static;let S="computedKey";N?S=p.id.name:l||p.type!=="Identifier"||(S=p.name);if(N&&!k){a&&(w=true);!m.types.isClassPrivateProperty(o)&&$||($=p)}r.isClassMethod({kind:"constructor"})&&(y=r);if(a){let o;let a;if(c===P){const{value:t}=r.node;const s=[m.types.thisExpression()];t&&s.push(m.types.cloneNode(t));const i=d();const c=r.scope.parent.generateDeclaredUidIdentifier(`init_${S}`);const u=m.types.callExpression(m.types.cloneNode(c),s);const f=generateClassProperty(i,u,k);const[y]=r.replaceWith(f);if(N){a=extractProxyAccessorsFor(i,n);const e=y.scope.parent.generateDeclaredUidIdentifier(`get_${S}`);const t=y.scope.parent.generateDeclaredUidIdentifier(`set_${S}`);addCallAccessorsFor(y,p,e,t);o=[c,e,t]}else{addProxyAccessorsFor(e.node.id,y,p,i,n,l);o=c}}else if(c===g){const e=r.scope.parent.generateDeclaredUidIdentifier(`init_${S}`);const t=r.get("value");t.replaceWith(m.types.callExpression(m.types.cloneNode(e),[m.types.thisExpression(),t.node].filter((e=>e))));o=e;N&&(a=extractProxyAccessorsFor(p,n))}else if(N){o=r.scope.parent.generateDeclaredUidIdentifier(`call_${S}`);const n=new h.default({constantSuper:s,methodPath:r,objectRef:I,superRef:e.node.superClass,file:t.file,refToPreserve:I});n.replace();const{params:i,body:l,async:d}=r.node;a=[m.types.functionExpression(void 0,i.filter(isNotTsParameter),l,d)];if(c===E||c===C)movePrivateAccessor(r,m.types.cloneNode(p),m.types.cloneNode(o),k);else{const t=r.node;e.node.body.body.unshift(m.types.classPrivateProperty(p,m.types.cloneNode(o),[],t.static));x.add(p.id.name);r.remove()}}let y;y=l?m.types.cloneNode(p):p.type==="PrivateName"?m.types.stringLiteral(p.id.name):p.type==="Identifier"?m.types.stringLiteral(p.name):m.types.cloneNode(p);u.push({kind:c,decorators:i.map((e=>e.node.expression)),decoratorsThis:i.map((e=>F.get(e.node))),name:y,isStatic:k,privateMethods:a,locals:o});c!==g&&(k?v=true:b=true);r.node&&(r.node.decorators=null);f||k||c!==g&&c!==P||(f=r)}}const M=generateDecorationExprs(u,n);let A=0;let L=[];if(a){const{hasThis:e,decs:t}=generateDecorationList(a.map((e=>e.expression)),a.map((e=>F.get(e))),n);A=e?1:0;L=t}const j=extractElementLocalAssignments(u);if(b){N=p.generateDeclaredUidIdentifier("initProto");j.push(N);const t=m.types.callExpression(m.types.cloneNode(N),[m.types.thisExpression()]);if(f){const e=f.get("value");const s=[t];e.node&&s.push(e.node);e.replaceWith(m.types.sequenceExpression(s))}else if(y)e.node.superClass?y.traverse({CallExpression:{exit(e){if(e.get("callee").isSuper()){e.replaceWith(m.types.callExpression(m.types.cloneNode(N),[e.node]));e.skip()}}},ClassMethod(e){e.node.kind==="constructor"&&e.skip()}}):y.node.body.body.unshift(m.types.expressionStatement(t));else{const s=[m.types.expressionStatement(t)];e.node.superClass&&s.unshift(m.types.expressionStatement(m.types.callExpression(m.types.super(),[m.types.spreadElement(m.types.identifier("args"))])));e.node.body.body.unshift(m.types.classMethod("constructor",m.types.identifier("constructor"),[m.types.restElement(m.types.identifier("args"))],m.types.blockStatement(s)))}}if(v){k=p.generateDeclaredUidIdentifier("initStatic");j.push(k)}x.size>0&&e.traverse({PrivateName(e){if(!x.has(e.node.id.name))return;const t=e.parentPath;const s=t.parentPath;if(s.node.type==="AssignmentExpression"&&s.node.left===t.node||s.node.type==="UpdateExpression"||s.node.type==="RestElement"||s.node.type==="ArrayPattern"||s.node.type==="ObjectProperty"&&s.node.value===t.node&&s.parentPath.type==="ObjectPattern"||s.node.type==="ForOfStatement"&&s.node.left===t.node)throw e.buildCodeFrameError(`Decorated private methods are not updatable, but "#${e.node.id.name}" is updated via this expression.`)}});const T=[];let O=false;const B=S&&m.types.callExpression(m.types.cloneNode(S),[]);const U=e.node;if(a){T.push(I,S);const s=[];let n=[];e.get("body.body").forEach((e=>{if(e.isStaticBlock()){n.push(e.node);e.remove();return}const t=e.isClassProperty()||e.isClassPrivateProperty();if((t||e.isClassPrivateMethod())&&e.node.static){if(t&&n.length>0){const t=n.map(staticBlockToIIFE);e.node.value&&t.push(e.node.value);e.node.value=maybeSequenceExpression(t);n=[]}e.node.static=false;s.push(e.node);e.remove()}}));if(s.length>0||n.length>0){const r=m.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;r.body.body=[m.types.staticBlock([m.types.toStatement(U,true)||m.types.expressionStatement(U)]),...s];const o=[];const i=m.types.newExpression(r,[]);n.length>0&&o.push(...n.map(staticBlockToIIFE));if(B){O=true;o.push(B)}if(o.length>0){o.unshift(m.types.callExpression(m.types.super(),[m.types.cloneNode(I)]));r.body.body.push(m.types.classMethod("constructor",m.types.identifier("constructor"),[],m.types.blockStatement([m.types.expressionStatement(m.types.sequenceExpression(o))])))}else i.arguments.push(m.types.cloneNode(I));e.replaceWith(i)}}!O&&B&&e.node.body.body.push(m.types.staticBlock([m.types.expressionStatement(B)]));let{superClass:_}=U;if(_&&n==="2023-05"){const t=e.scope.maybeGenerateMemoised(_);if(t){U.superClass=m.types.assignmentExpression("=",t,_);_=t}}U.body.body.unshift(m.types.staticBlock([m.types.expressionStatement(createLocalsAssignment(j,T,M,m.types.arrayExpression(L),m.types.numericLiteral(A),w?$:null,typeof r==="object"?r:void 0,m.types.cloneNode(_),t,n)),v&&m.types.expressionStatement(m.types.callExpression(m.types.cloneNode(k),[m.types.thisExpression()]))].filter(Boolean)));e.insertBefore(c.map((e=>m.types.expressionStatement(e))));D&&e.insertBefore(m.types.variableDeclaration("let",[m.types.variableDeclarator(m.types.cloneNode(I))]));e.scope.crawl();return e}function createLocalsAssignment(e,t,s,n,r,o,i,a,l,d){let c,p;const u=[i?createSetFunctionNameCall(l,i):m.types.thisExpression(),s,n];if(d==="2021-12"||d==="2022-03"&&!l.availableHelper("applyDecs2203R")){const s=m.types.arrayPattern([...e,...t]);const n=m.types.callExpression(l.addHelper(d==="2021-12"?"applyDecs":"applyDecs2203"),u);return m.types.assignmentExpression("=",s,n)}if(d==="2023-05"){(o||a||r.value!==0)&&u.push(r);o?u.push(m.template.expression.ast`
            _ => ${m.types.cloneNode(o)} in _
          `):a&&u.push(m.types.unaryExpression("void",m.types.numericLiteral(0)));a&&u.push(a);p=m.types.callExpression(l.addHelper("applyDecs2305"),u)}else if(d==="2023-01"){o&&u.push(m.template.expression.ast`
            _ => ${m.types.cloneNode(o)} in _
          `);p=m.types.callExpression(l.addHelper("applyDecs2301"),u)}else p=m.types.callExpression(l.addHelper("applyDecs2203R"),u);if(e.length>0)if(t.length>0)c=m.types.objectPattern([m.types.objectProperty(m.types.identifier("e"),m.types.arrayPattern(e)),m.types.objectProperty(m.types.identifier("c"),m.types.arrayPattern(t))]);else{c=m.types.arrayPattern(e);p=m.types.memberExpression(p,m.types.identifier("e"),false,false)}else{c=m.types.arrayPattern(t);p=m.types.memberExpression(p,m.types.identifier("c"),false,false)}return m.types.assignmentExpression("=",c,p)}function isProtoKey(e){return e.type==="Identifier"?e.name==="__proto__":e.value==="__proto__"}function isDecorated(e){return e.decorators&&e.decorators.length>0}function shouldTransformElement(e){switch(e.type){case"ClassAccessorProperty":return true;case"ClassMethod":case"ClassProperty":case"ClassPrivateMethod":case"ClassPrivateProperty":return isDecorated(e);default:return false}}function shouldTransformClass(e){return isDecorated(e)||e.body.body.some(shouldTransformElement)}function NamedEvaluationVisitoryFactory(e,t){function handleComputedProperty(e,t,s){switch(t.type){case"StringLiteral":return m.types.stringLiteral(t.value);case"NumericLiteral":case"BigIntLiteral":{const s=t.value+"";e.get("key").replaceWith(m.types.stringLiteral(s));return m.types.stringLiteral(s)}default:{const n=e.scope.maybeGenerateMemoised(t);e.get("key").replaceWith(m.types.assignmentExpression("=",n,createToPropertyKeyCall(s,t)));return m.types.cloneNode(n)}}}return{VariableDeclarator(s,n){const r=s.node.id;if(r.type==="Identifier"){const o=(0,v.skipTransparentExprWrappers)(s.get("init"));if(e(o)){const e=r.name;t(o,n,e)}}},AssignmentExpression(s,n){const r=s.node.left;if(r.type==="Identifier"){const o=(0,v.skipTransparentExprWrappers)(s.get("right"));if(e(o))switch(s.node.operator){case"=":case"&&=":case"||=":case"??=":t(o,n,r.name)}}},AssignmentPattern(s,n){const r=s.node.left;if(r.type==="Identifier"){const o=(0,v.skipTransparentExprWrappers)(s.get("right"));if(e(o)){const e=r.name;t(o,n,e)}}},ObjectExpression(s,n){for(const r of s.get("properties")){const{node:s}=r;if(s.type!=="ObjectProperty")continue;const o=s.key;const i=(0,v.skipTransparentExprWrappers)(r.get("value"));if(e(i))if(s.computed){const e=handleComputedProperty(r,o,n);t(i,n,e)}else if(!isProtoKey(o))if(o.type==="Identifier")t(i,n,o.name);else{const e=m.types.stringLiteral(o.value+"");t(i,n,e)}}},ClassPrivateProperty(s,n){const{node:r}=s;const o=(0,v.skipTransparentExprWrappers)(s.get("value"));if(e(o)){const e=m.types.stringLiteral("#"+r.key.id.name);t(o,n,e)}},ClassAccessorProperty(s,n){const{node:r}=s;const o=r.key;const i=(0,v.skipTransparentExprWrappers)(s.get("value"));if(e(i))if(r.computed){const e=handleComputedProperty(s,o,n);t(i,n,e)}else if(o.type==="Identifier")t(i,n,o.name);else if(o.type==="PrivateName"){const e=m.types.stringLiteral("#"+o.id.name);t(i,n,e)}else{const e=m.types.stringLiteral(o.value+"");t(i,n,e)}},ClassProperty(s,n){const{node:r}=s;const o=r.key;const i=(0,v.skipTransparentExprWrappers)(s.get("value"));if(e(i))if(r.computed){const e=handleComputedProperty(s,o,n);t(i,n,e)}else if(o.type==="Identifier")t(i,n,o.name);else{const e=m.types.stringLiteral(o.value+"");t(i,n,e)}}}}function isDecoratedAnonymousClassExpression(e){return e.isClassExpression({id:null})&&shouldTransformClass(e.node)}function _default({assertVersion:e,assumption:t},{loose:s},n,r){var o;e(n==="2023-05"||n==="2023-01"?"^7.21.0":n==="2021-12"?"^7.16.0":"^7.19.0");const i=new WeakSet;const a=(o=t("constantSuper"))!=null?o:s;const l=NamedEvaluationVisitoryFactory(isDecoratedAnonymousClassExpression,visitClass);function visitClass(e,t,s){var r,o;if(i.has(e))return;const{node:d}=e;(r=s)!=null?r:s=(o=d.id)==null?void 0:o.name;const c=transformClass(e,t,a,n,s,l);c?i.add(c):i.add(e)}return{name:"proposal-decorators",inherits:r,visitor:Object.assign({ExportDefaultDeclaration(e,t){const{declaration:s}=e.node;if((s==null?void 0:s.type)==="ClassDeclaration"&&isDecorated(s)){const n=!s.id;const r=(0,b.default)(e);n&&visitClass(r,t,m.types.stringLiteral("default"))}},ExportNamedDeclaration(e){const{declaration:t}=e.node;(t==null?void 0:t.type)==="ClassDeclaration"&&isDecorated(t)&&(0,b.default)(e)},Class(e,t){visitClass(e,t,void 0)}},l)}}var I={};Object.defineProperty(I,"__esModule",{value:true});I.assertFieldTransformed=assertFieldTransformed;function assertFieldTransformed(e){if(e.node.declare||false)throw e.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators")}var F=e;try{"default"in e&&(F=e.default)}catch(e){}var D=n;try{"default"in n&&(D=n.default)}catch(e){}var $=i;try{"default"in i&&($=i.default)}catch(e){}var w=a;try{"default"in a&&(w=a.default)}catch(e){}var M=l;try{"default"in l&&(M=l.default)}catch(e){}var A=d;try{"default"in d&&(A=d.default)}catch(e){}var L=r;try{"default"in r&&(L=r.default)}catch(e){}var j={};Object.defineProperty(j,"__esModule",{value:true});j.buildCheckInRHS=buildCheckInRHS$1;j.buildFieldsInitNodes=buildFieldsInitNodes;j.buildPrivateNamesMap=buildPrivateNamesMap;j.buildPrivateNamesNodes=buildPrivateNamesNodes;j.transformPrivateNamesUsage=transformPrivateNamesUsage;var T=F;var O=D;var B=$;var U=w;var _=M;var R=A;var H=L;var W=I;function buildPrivateNamesMap(e){const t=new Map;for(const s of e)if(s.isPrivate()){const{name:e}=s.node.key.id;const n=t.has(e)?t.get(e):{id:s.scope.generateUidIdentifier(e),static:s.node.static,method:!s.isProperty()};s.isClassPrivateMethod()&&(s.node.kind==="get"?n.getId=s.scope.generateUidIdentifier(`get_${e}`):s.node.kind==="set"?n.setId=s.scope.generateUidIdentifier(`set_${e}`):s.node.kind==="method"&&(n.methodId=s.scope.generateUidIdentifier(e)));t.set(e,n)}return t}function buildPrivateNamesNodes(e,t,s,n){const r=[];for(const[o,i]of e){const{static:e,method:a,getId:l,setId:d}=i;const c=l||d;const p=T.types.cloneNode(i.id);let u;t?u=T.types.callExpression(n.addHelper("classPrivateFieldLooseKey"),[T.types.stringLiteral(o)]):s?u=T.types.callExpression(T.types.identifier("Symbol"),[T.types.stringLiteral(o)]):e||(u=T.types.newExpression(T.types.identifier(!a||c?"WeakMap":"WeakSet"),[]));if(u){(0,R.default)(u);r.push(T.template.statement.ast`var ${p} = ${u}`)}}return r}function privateNameVisitorFactory(e){const t=T.traverse.visitors.merge([Object.assign({},e),B.default]);const s=Object.assign({},e,{Class(e){const{privateNamesMap:n}=this;const r=e.get("body.body");const o=new Map(n);const i=[];for(const e of r){if(!e.isPrivate())continue;const{name:t}=e.node.key.id;o.delete(t);i.push(t)}if(i.length){e.get("body").traverse(t,Object.assign({},this,{redeclared:i}));e.traverse(s,Object.assign({},this,{privateNamesMap:o}));e.skipKey("body")}}});return s}const K=privateNameVisitorFactory({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:s,redeclared:n}=this;const{node:r,parentPath:o}=e;if(!o.isMemberExpression({property:r})&&!o.isOptionalMemberExpression({property:r}))return;const{name:i}=r.id;s.has(i)&&(n&&n.includes(i)||this.handle(o,t))}});function unshadow(e,t,s){while((n=t)!=null&&n.hasBinding(e)&&!t.bindingIdentifierEquals(e,s)){var n;t.rename(e);t=t.parent}}function buildCheckInRHS$1(e,t,s){return s||!(t.availableHelper!=null&&t.availableHelper("checkInRHS"))?e:T.types.callExpression(t.addHelper("checkInRHS"),[e])}const z=privateNameVisitorFactory({BinaryExpression(e,{file:t}){const{operator:s,left:n,right:r}=e.node;if(s!=="in")return;if(!T.types.isPrivateName(n))return;const{privateFieldsAsProperties:o,privateNamesMap:i,redeclared:a}=this;const{name:l}=n.id;if(!i.has(l))return;if(a&&a.includes(l))return;unshadow(this.classRef.name,e.scope,this.innerBinding);if(o){const{id:s}=i.get(l);e.replaceWith(T.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS$1(r,t)}, ${T.types.cloneNode(s)})
      `);return}const{id:d,static:c}=i.get(l);c?e.replaceWith(T.template.expression.ast`${buildCheckInRHS$1(r,t)} === ${T.types.cloneNode(this.classRef)}`):e.replaceWith(T.template.expression.ast`${T.types.cloneNode(d)}.has(${buildCheckInRHS$1(r,t)})`)}});const G={memoise(e,t){const{scope:s}=e;const{object:n}=e.node;const r=s.maybeGenerateMemoised(n);r&&this.memoiser.set(n,r,t)},receiver(e){const{object:t}=e.node;return this.memoiser.has(t)?T.types.cloneNode(this.memoiser.get(t)):T.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:s,file:n,innerBinding:r}=this;const{name:o}=e.node.property.id;const{id:i,static:a,method:l,methodId:d,getId:c,setId:p}=s.get(o);const u=c||p;if(a){const s=l&&!u?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";unshadow(t.name,e.scope,r);return T.types.callExpression(n.addHelper(s),[this.receiver(e),T.types.cloneNode(t),T.types.cloneNode(i)])}if(l){if(u){if(!c&&p){if(n.availableHelper("writeOnlyError"))return T.types.sequenceExpression([this.receiver(e),T.types.callExpression(n.addHelper("writeOnlyError"),[T.types.stringLiteral(`#${o}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.")}return T.types.callExpression(n.addHelper("classPrivateFieldGet"),[this.receiver(e),T.types.cloneNode(i)])}return T.types.callExpression(n.addHelper("classPrivateMethodGet"),[this.receiver(e),T.types.cloneNode(i),T.types.cloneNode(d)])}return T.types.callExpression(n.addHelper("classPrivateFieldGet"),[this.receiver(e),T.types.cloneNode(i)])},boundGet(e){this.memoise(e,1);return T.types.callExpression(T.types.memberExpression(this.get(e),T.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:s,privateNamesMap:n,file:r}=this;const{name:o}=e.node.property.id;const{id:i,static:a,method:l,setId:d,getId:c}=n.get(o);const p=c||d;if(a){const n=l&&!p?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return T.types.callExpression(r.addHelper(n),[this.receiver(e),T.types.cloneNode(s),T.types.cloneNode(i),t])}return l?d?T.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),T.types.cloneNode(i),t]):T.types.sequenceExpression([this.receiver(e),t,T.types.callExpression(r.addHelper("readOnlyError"),[T.types.stringLiteral(`#${o}`)])]):T.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),T.types.cloneNode(i),t])},destructureSet(e){const{classRef:t,privateNamesMap:s,file:n}=this;const{name:r}=e.node.property.id;const{id:o,static:i}=s.get(r);if(i){try{var a=n.addHelper("classStaticPrivateFieldDestructureSet")}catch(e){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return T.types.memberExpression(T.types.callExpression(a,[this.receiver(e),T.types.cloneNode(t),T.types.cloneNode(o)]),T.types.identifier("value"))}return T.types.memberExpression(T.types.callExpression(n.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),T.types.cloneNode(o)]),T.types.identifier("value"))},call(e,t){this.memoise(e,1);return(0,_.default)(this.get(e),this.receiver(e),t,false)},optionalCall(e,t){this.memoise(e,1);return(0,_.default)(this.get(e),this.receiver(e),t,true)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}};const q={get(e){const{privateNamesMap:t,file:s}=this;const{object:n}=e.node;const{name:r}=e.node.property.id;return T.template.expression`BASE(REF, PROP)[PROP]`({BASE:s.addHelper("classPrivateFieldLooseBase"),REF:T.types.cloneNode(n),PROP:T.types.cloneNode(t.get(r).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(e){return T.types.callExpression(T.types.memberExpression(this.get(e),T.types.identifier("bind")),[T.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return T.types.callExpression(this.get(e),t)},optionalCall(e,t){return T.types.optionalCallExpression(this.get(e),t,true)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}};function transformPrivateNamesUsage(e,t,s,{privateFieldsAsProperties:n,noDocumentAll:r,innerBinding:o},i){if(!s.size)return;const a=t.get("body");const l=n?q:G;(0,U.default)(a,K,Object.assign({privateNamesMap:s,classRef:e,file:i},l,{noDocumentAll:r,innerBinding:o}));a.traverse(z,{privateNamesMap:s,classRef:e,file:i,privateFieldsAsProperties:n,innerBinding:o})}function buildPrivateFieldInitLoose(e,t,s){const{id:n}=s.get(t.node.key.id.name);const r=t.node.value||t.scope.buildUndefinedNode();return inheritPropComments(T.template.statement.ast`
      Object.defineProperty(${e}, ${T.types.cloneNode(n)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${r}
      });
    `,t)}function buildPrivateInstanceFieldInitSpec(e,t,s,n){const{id:r}=s.get(t.node.key.id.name);const o=t.node.value||t.scope.buildUndefinedNode();if(!n.availableHelper("classPrivateFieldInitSpec"))return inheritPropComments(T.template.statement.ast`${T.types.cloneNode(r)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${o},
        })`,t);const i=n.addHelper("classPrivateFieldInitSpec");return inheritPropComments(T.template.statement.ast`${i}(
      ${T.types.thisExpression()},
      ${T.types.cloneNode(r)},
      {
        writable: true,
        value: ${o}
      },
    )`,t)}function buildPrivateStaticFieldInitSpec(e,t){const s=t.get(e.node.key.id.name);const{id:n,getId:r,setId:o,initAdded:i}=s;const a=r||o;if(!e.isProperty()&&(i||!a))return;if(a){t.set(e.node.key.id.name,Object.assign({},s,{initAdded:true}));return inheritPropComments(T.template.statement.ast`
        var ${T.types.cloneNode(n)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${r?r.name:e.scope.buildUndefinedNode()},
          set: ${o?o.name:e.scope.buildUndefinedNode()}
        }
      `,e)}const l=e.node.value||e.scope.buildUndefinedNode();return inheritPropComments(T.template.statement.ast`
      var ${T.types.cloneNode(n)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${l}
      };
    `,e)}function buildPrivateMethodInitLoose(e,t,s){const n=s.get(t.node.key.id.name);const{methodId:r,id:o,getId:i,setId:a,initAdded:l}=n;if(l)return;if(r)return inheritPropComments(T.template.statement.ast`
        Object.defineProperty(${e}, ${o}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${r.name}
        });
      `,t);const d=i||a;if(d){s.set(t.node.key.id.name,Object.assign({},n,{initAdded:true}));return inheritPropComments(T.template.statement.ast`
        Object.defineProperty(${e}, ${o}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${i?i.name:t.scope.buildUndefinedNode()},
          set: ${a?a.name:t.scope.buildUndefinedNode()}
        });
      `,t)}}function buildPrivateInstanceMethodInitSpec(e,t,s,n){const r=s.get(t.node.key.id.name);const{getId:o,setId:i,initAdded:a}=r;if(a)return;const l=o||i;return l?buildPrivateAccessorInitialization(e,t,s,n):buildPrivateInstanceMethodInitialization(e,t,s,n)}function buildPrivateAccessorInitialization(e,t,s,n){const r=s.get(t.node.key.id.name);const{id:o,getId:i,setId:a}=r;s.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));if(!n.availableHelper("classPrivateFieldInitSpec"))return inheritPropComments(T.template.statement.ast`
          ${o}.set(${e}, {
            get: ${i?i.name:t.scope.buildUndefinedNode()},
            set: ${a?a.name:t.scope.buildUndefinedNode()}
          });
        `,t);const l=n.addHelper("classPrivateFieldInitSpec");return inheritPropComments(T.template.statement.ast`${l}(
      ${T.types.thisExpression()},
      ${T.types.cloneNode(o)},
      {
        get: ${i?i.name:t.scope.buildUndefinedNode()},
        set: ${a?a.name:t.scope.buildUndefinedNode()}
      },
    )`,t)}function buildPrivateInstanceMethodInitialization(e,t,s,n){const r=s.get(t.node.key.id.name);const{id:o}=r;if(!n.availableHelper("classPrivateMethodInitSpec"))return inheritPropComments(T.template.statement.ast`${o}.add(${e})`,t);const i=n.addHelper("classPrivateMethodInitSpec");return inheritPropComments(T.template.statement.ast`${i}(
      ${T.types.thisExpression()},
      ${T.types.cloneNode(o)}
    )`,t)}function buildPublicFieldInitLoose(e,t){const{key:s,computed:n}=t.node;const r=t.node.value||t.scope.buildUndefinedNode();return inheritPropComments(T.types.expressionStatement(T.types.assignmentExpression("=",T.types.memberExpression(e,s,n||T.types.isLiteral(s)),r)),t)}function buildPublicFieldInitSpec(e,t,s){const{key:n,computed:r}=t.node;const o=t.node.value||t.scope.buildUndefinedNode();return inheritPropComments(T.types.expressionStatement(T.types.callExpression(s.addHelper("defineProperty"),[e,r||T.types.isLiteral(n)?n:T.types.stringLiteral(n.name),o])),t)}function buildPrivateStaticMethodInitLoose(e,t,s,n){const r=n.get(t.node.key.id.name);const{id:o,methodId:i,getId:a,setId:l,initAdded:d}=r;if(d)return;const c=a||l;if(c){n.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));return inheritPropComments(T.template.statement.ast`
        Object.defineProperty(${e}, ${o}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${a?a.name:t.scope.buildUndefinedNode()},
          set: ${l?l.name:t.scope.buildUndefinedNode()}
        })
      `,t)}return inheritPropComments(T.template.statement.ast`
      Object.defineProperty(${e}, ${o}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${i.name}
      });
    `,t)}function buildPrivateMethodDeclaration(e,t,s=false){const n=t.get(e.node.key.id.name);const{id:r,methodId:o,getId:i,setId:a,getterDeclared:l,setterDeclared:d,static:c}=n;const{params:p,body:u,generator:f,async:y}=e.node;const m=i&&!l&&p.length===0;const h=a&&!d&&p.length>0;let b=o;if(m){t.set(e.node.key.id.name,Object.assign({},n,{getterDeclared:true}));b=i}else if(h){t.set(e.node.key.id.name,Object.assign({},n,{setterDeclared:true}));b=a}else c&&!s&&(b=r);return inheritPropComments(T.types.functionDeclaration(T.types.cloneNode(b),p,u,f,y),e)}const V=T.traverse.visitors.merge([{UnaryExpression(e){const{node:t}=e;if(t.operator==="delete"){const s=(0,H.skipTransparentExprWrapperNodes)(t.argument);T.types.isThisExpression(s)&&e.replaceWith(T.types.booleanLiteral(true))}},ThisExpression(e,t){t.needsClassRef=true;e.replaceWith(T.types.cloneNode(t.classRef))},MetaProperty(e){const{node:t,scope:s}=e;t.meta.name==="new"&&t.property.name==="target"&&e.replaceWith(s.buildUndefinedNode())}},B.default]);const Z={ReferencedIdentifier(e,t){if(e.scope.bindingIdentifierEquals(e.node.name,t.innerBinding)){t.needsClassRef=true;e.node.name=t.classRef.name}}};function replaceThisContext(e,t,s){var n;const r={classRef:t,needsClassRef:false,innerBinding:s};e.isMethod()||e.traverse(V,r);s!=null&&(n=r.classRef)!=null&&n.name&&r.classRef.name!==s.name&&e.traverse(Z,r);return r.needsClassRef}function isNameOrLength({key:e,computed:t}){return e.type==="Identifier"?!t&&(e.name==="name"||e.name==="length"):e.type==="StringLiteral"&&(e.value==="name"||e.value==="length")}function inheritPropComments(e,t){T.types.inheritLeadingComments(e,t.node);T.types.inheritInnerComments(e,t.node);return e}function buildFieldsInitNodes(e,t,s,n,r,o,i,a,l){var d,c;let p=0;let u;const f=[];const y=[];let m=false;const h=[];let b=null;const v=T.types.isIdentifier(t)?()=>t:()=>{var e;(e=u)!=null?e:u=s[0].scope.generateUidIdentifierBasedOnNode(t);return u};const g=(d=e)!=null?d:s[0].scope.generateUidIdentifier("class");(c=e)!=null?c:e=T.types.cloneNode(l);for(const t of s){t.isClassProperty()&&W.assertFieldTransformed(t);const s=!(T.types.isStaticBlock!=null&&T.types.isStaticBlock(t.node))&&t.node.static;const d=!s;const c=t.isPrivate();const u=!c;const b=t.isProperty();const P=!b;const x=t.isStaticBlock==null?void 0:t.isStaticBlock();s&&(p|=1);if(s||P&&c||x){new O.default({methodPath:t,constantSuper:a,file:r,refToPreserve:l,getSuperRef:v,getObjectRef(){p|=2;return s||x?g:T.types.memberExpression(g,T.types.identifier("prototype"))}}).replace();const e=replaceThisContext(t,g,l);e&&(p|=2)}m=false;switch(true){case x:{const e=t.node.body;e.length===1&&T.types.isExpressionStatement(e[0])?f.push(inheritPropComments(e[0],t)):f.push(T.types.inheritsComments(T.template.statement.ast`(() => { ${e} })()`,t.node));break}case s&&c&&b&&i:f.push(buildPrivateFieldInitLoose(T.types.cloneNode(e),t,n));break;case s&&c&&b&&!i:f.push(buildPrivateStaticFieldInitSpec(t,n));break;case s&&u&&b&&o:if(!isNameOrLength(t.node)){f.push(buildPublicFieldInitLoose(T.types.cloneNode(e),t));break}case s&&u&&b&&!o:f.push(buildPublicFieldInitSpec(T.types.cloneNode(e),t,r));break;case d&&c&&b&&i:y.push(buildPrivateFieldInitLoose(T.types.thisExpression(),t,n));break;case d&&c&&b&&!i:y.push(buildPrivateInstanceFieldInitSpec(T.types.thisExpression(),t,n,r));break;case d&&c&&P&&i:y.unshift(buildPrivateMethodInitLoose(T.types.thisExpression(),t,n));h.push(buildPrivateMethodDeclaration(t,n,i));break;case d&&c&&P&&!i:y.unshift(buildPrivateInstanceMethodInitSpec(T.types.thisExpression(),t,n,r));h.push(buildPrivateMethodDeclaration(t,n,i));break;case s&&c&&P&&!i:f.unshift(buildPrivateStaticFieldInitSpec(t,n));h.push(buildPrivateMethodDeclaration(t,n,i));break;case s&&c&&P&&i:f.unshift(buildPrivateStaticMethodInitLoose(T.types.cloneNode(e),t,r,n));h.push(buildPrivateMethodDeclaration(t,n,i));break;case d&&u&&b&&o:y.push(buildPublicFieldInitLoose(T.types.thisExpression(),t));break;case d&&u&&b&&!o:m=true;y.push(buildPublicFieldInitSpec(T.types.thisExpression(),t,r));break;default:throw new Error("Unreachable.")}}p&2&&l!=null&&(b=T.types.expressionStatement(T.types.assignmentExpression("=",T.types.cloneNode(g),T.types.cloneNode(l))));return{staticNodes:f.filter(Boolean),instanceNodes:y.filter(Boolean),lastInstanceNodeReturnsThis:m,pureStaticNodes:h.filter(Boolean),classBindingNode:b,wrapClass(t){for(const e of s){e.node.leadingComments=null;e.remove()}if(u){t.scope.push({id:T.types.cloneNode(u)});t.set("superClass",T.types.assignmentExpression("=",u,t.node.superClass))}if(p!==0)if(t.isClassExpression()){t.scope.push({id:e});t.replaceWith(T.types.assignmentExpression("=",T.types.cloneNode(e),t.node))}else{l==null&&(t.node.id=e);b!=null&&t.scope.push({id:g})}return t}}}var Y=e;try{"default"in e&&(Y=e.default)}catch(e){}var J=n;try{"default"in n&&(J=n.default)}catch(e){}var Q=t;try{"default"in t&&(Q=t.default)}catch(e){}var X={};Object.defineProperty(X,"__esModule",{value:true});X.buildDecoratedClass=buildDecoratedClass;X.hasDecorators=hasDecorators;X.hasOwnDecorators=hasOwnDecorators;var ee=Y;var te=J;var se=Q;function hasOwnDecorators(e){var t;return!!((t=e.decorators)!=null&&t.length)}function hasDecorators(e){return hasOwnDecorators(e)||e.body.body.some(hasOwnDecorators)}function prop(e,t){return t?ee.types.objectProperty(ee.types.identifier(e),t):null}function method(e,t){return ee.types.objectMethod("method",ee.types.identifier(e),[],ee.types.blockStatement(t))}function takeDecorators(e){let t;e.decorators&&e.decorators.length>0&&(t=ee.types.arrayExpression(e.decorators.map((e=>e.expression))));e.decorators=void 0;return t}function getKey(e){return e.computed?e.key:ee.types.isIdentifier(e.key)?ee.types.stringLiteral(e.key.name):ee.types.stringLiteral(String(e.key.value))}function extractElementDescriptor(e,t,s,n){const r=n.isClassMethod();if(n.isPrivate())throw n.buildCodeFrameError(`Private ${r?"methods":"fields"} in decorated classes are not supported yet.`);if(n.node.type==="ClassAccessorProperty")throw n.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');if(n.node.type==="StaticBlock")throw n.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');const{node:o,scope:i}=n;n.isTSDeclareMethod()||new te.default({methodPath:n,objectRef:t,superRef:s,file:e,refToPreserve:t}).replace();const a=[prop("kind",ee.types.stringLiteral(ee.types.isClassMethod(o)?o.kind:"field")),prop("decorators",takeDecorators(o)),prop("static",o.static&&ee.types.booleanLiteral(true)),prop("key",getKey(o))].filter(Boolean);if(ee.types.isClassMethod(o)){const e=o.computed?null:o.key;const t=ee.types.toExpression(o);a.push(prop("value",(0,se.default)({node:t,id:e,scope:i})||t))}else ee.types.isClassProperty(o)&&o.value?a.push(method("value",ee.template.statements.ast`return ${o.value}`)):a.push(prop("value",i.buildUndefinedNode()));n.remove();return ee.types.objectExpression(a)}function addDecorateHelper(e){return e.addHelper("decorate")}function buildDecoratedClass(e,t,s,n){const{node:r,scope:o}=t;const i=o.generateUidIdentifier("initialize");const a=r.id&&t.isDeclaration();const l=t.isInStrictMode();const{superClass:d}=r;r.type="ClassDeclaration";r.id||(r.id=ee.types.cloneNode(e));let c;if(d){c=o.generateUidIdentifierBasedOnNode(r.superClass,"super");r.superClass=c}const p=takeDecorators(r);const u=ee.types.arrayExpression(s.filter((e=>!e.node.abstract&&e.node.type!=="TSIndexSignature")).map((e=>extractElementDescriptor(n,r.id,c,e))));const f=ee.template.expression.ast`
    ${addDecorateHelper(n)}(
      ${p||ee.types.nullLiteral()},
      function (${i}, ${d?ee.types.cloneNode(c):null}) {
        ${r}
        return { F: ${ee.types.cloneNode(r.id)}, d: ${u} };
      },
      ${d}
    )
  `;l||f.arguments[1].body.directives.push(ee.types.directive(ee.types.directiveLiteral("use strict")));let y=f;let m="arguments.1.body.body.0";if(a){y=ee.template.statement.ast`let ${e} = ${f}`;m="declarations.0.init."+m}return{instanceNodes:[ee.template.statement.ast`
        ${ee.types.cloneNode(i)}(this)
      `],wrapClass(e){e.replaceWith(y);return e.get(m)}}}var ne=e;try{"default"in e&&(ne=e.default)}catch(e){}var re=i;try{"default"in i&&(re=i.default)}catch(e){}var oe={};Object.defineProperty(oe,"__esModule",{value:true});oe.extractComputedKeys=extractComputedKeys;oe.injectInitialization=injectInitialization$1;var ie=ne;var ae=re;const le=ie.traverse.visitors.merge([{Super(e){const{node:t,parentPath:s}=e;s.isCallExpression({callee:t})&&this.push(s)}},ae.default]);const de={"TSTypeAnnotation|TypeAnnotation"(e){e.skip()},ReferencedIdentifier(e,{scope:t}){if(t.hasOwnBinding(e.node.name)){t.rename(e.node.name);e.skip()}}};function handleClassTDZ(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const s=t.file.addHelper("classNameTDZError");const n=ie.types.callExpression(s,[ie.types.stringLiteral(e.node.name)]);e.replaceWith(ie.types.sequenceExpression([n,e.node]));e.skip()}}const ce={ReferencedIdentifier:handleClassTDZ};function injectInitialization$1(e,t,s,n,r){if(!s.length)return;const o=!!e.node.superClass;if(!t){const s=ie.types.classMethod("constructor",ie.types.identifier("constructor"),[],ie.types.blockStatement([]));if(o){s.params=[ie.types.restElement(ie.types.identifier("args"))];s.body.body.push(ie.template.statement.ast`super(...args)`)}[t]=e.get("body").unshiftContainer("body",s)}n&&n(de,{scope:t.scope});if(o){const e=[];t.traverse(le,e);let n=true;for(const t of e){n?n=false:s=s.map((e=>ie.types.cloneNode(e)));if(t.parentPath.isExpressionStatement())t.insertAfter(s);else{const e=[t.node,...s.map((e=>ie.types.toExpression(e)))];r||e.push(ie.types.thisExpression());t.replaceWith(ie.types.sequenceExpression(e))}}}else t.get("body").unshiftContainer("body",s)}function extractComputedKeys(e,t,s){const n=[];const r={classBinding:e.node.id&&e.scope.getBinding(e.node.id.name),file:s};for(const s of t){const t=s.get("key");t.isReferencedIdentifier()?handleClassTDZ(t,r):t.traverse(ce,r);const o=s.node;if(!t.isConstantExpression()){const s=e.scope;const r=ie.types.isIdentifier(t.node)&&s.hasUid(t.node.name);const i=t.isAssignmentExpression({operator:"="})&&ie.types.isIdentifier(t.node.left)&&s.hasUid(t.node.left.name);if(r)continue;if(i){n.push(ie.types.expressionStatement(ie.types.cloneNode(o.key)));o.key=ie.types.cloneNode(o.key.left)}else{const t=e.scope.generateUidIdentifierBasedOnNode(o.key);s.push({id:t,kind:"let"});n.push(ie.types.expressionStatement(ie.types.assignmentExpression("=",ie.types.cloneNode(t),o.key)));o.key=ie.types.cloneNode(t)}}}return n}var pe={};Object.defineProperty(pe,"__esModule",{value:true});pe.FEATURES=void 0;pe.enableFeature=enableFeature$1;pe.isLoose=isLoose;pe.shouldTransform=shouldTransform;var ue=X;const fe=pe.FEATURES=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});const ye=new Map([[fe.fields,"@babel/plugin-transform-class-properties"],[fe.privateMethods,"@babel/plugin-transform-private-methods"],[fe.privateIn,"@babel/plugin-transform-private-property-in-object"]]);const me="@babel/plugin-class-features/featuresKey";const he="@babel/plugin-class-features/looseKey";var be="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";var canIgnoreLoose=function(e,t){return!!(e.get(be)&t)};function enableFeature$1(e,t,s){if(!hasFeature(e,t)||canIgnoreLoose(e,t)){e.set(me,e.get(me)|t);if(s==="#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"){setLoose(e,t,true);e.set(be,e.get(be)|t)}else if(s==="#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"){setLoose(e,t,false);e.set(be,e.get(be)|t)}else setLoose(e,t,s)}let n;for(const[t,s]of ye){if(!hasFeature(e,t))continue;if(canIgnoreLoose(e,t))continue;const o=isLoose(e,t);if(n===!o)throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");n=o;var r=s}if(n!==void 0)for(const[t,s]of ye)if(hasFeature(e,t)&&isLoose(e,t)!==n){setLoose(e,t,n);console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env config, it will not be used for ${s} since the "loose" mode option was set to "${n}" for ${r}.\nThe "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${s}", { "loose": ${n} }]\nto the "plugins" section of your Babel config.`)}}function hasFeature(e,t){return!!(e.get(me)&t)}function isLoose(e,t){return!!(e.get(he)&t)}function setLoose(e,t,s){s?e.set(he,e.get(he)|t):e.set(he,e.get(he)&~t);e.set(be,e.get(be)&~t)}function shouldTransform(e,t){let s=null;let n=null;let r=null;let o=null;let i=null;(0,ue.hasOwnDecorators)(e.node)&&(s=e.get("decorators.0"));for(const t of e.get("body.body")){!s&&(0,ue.hasOwnDecorators)(t.node)&&(s=t.get("decorators.0"));!n&&t.isClassProperty()&&(n=t);!r&&t.isClassPrivateProperty()&&(r=t);!o&&t.isClassPrivateMethod!=null&&t.isClassPrivateMethod()&&(o=t);!i&&t.isStaticBlock!=null&&t.isStaticBlock()&&(i=t)}if(s&&r)throw r.buildCodeFrameError("Private fields in decorated classes are not supported yet.");if(s&&o)throw o.buildCodeFrameError("Private methods in decorated classes are not supported yet.");if(s&&!hasFeature(t,fe.decorators))throw e.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n\t["@babel/plugin-transform-class-properties", { "loose": true }]');if(o&&!hasFeature(t,fe.privateMethods))throw o.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");if((n||r)&&!hasFeature(t,fe.fields)&&!hasFeature(t,fe.privateMethods))throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");if(i&&!hasFeature(t,fe.staticBlocks))throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");return!!(s||o||i)||!(!n&&!r||!hasFeature(t,fe.fields))}var ve=e;try{"default"in e&&(ve=e.default)}catch(e){}var ge=t;try{"default"in t&&(ge=t.default)}catch(e){}var Pe=s;try{"default"in s&&(Pe=s.default)}catch(e){}var xe=o;try{"default"in o&&(xe=o.default)}catch(e){}var Ee={};Object.defineProperty(Ee,"__esModule",{value:true});Object.defineProperty(Ee,"FEATURES",{enumerable:true,get:function(){return we.FEATURES}});Object.defineProperty(Ee,"buildCheckInRHS",{enumerable:true,get:function(){return Fe.buildCheckInRHS}});Ee.createClassFeaturePlugin=createClassFeaturePlugin;Object.defineProperty(Ee,"enableFeature",{enumerable:true,get:function(){return we.enableFeature}});Object.defineProperty(Ee,"injectInitialization",{enumerable:true,get:function(){return $e.injectInitialization}});var Ce=ve;var Ne=ge;var ke=Pe;var Se=y;var Ie=xe;var Fe=j;var De=X;var $e=oe;var we=pe;var Me=I;const Ae="@babel/plugin-class-features/version";function createClassFeaturePlugin({name:e,feature:t,loose:s,manipulateOptions:n,api:r,inherits:o,decoratorVersion:i}){if(t&we.FEATURES.decorators&&(i==="2021-12"||i==="2022-03"||i==="2023-01"||i==="2023-05"))return(0,Se.default)(r,{loose:s},i,o);var a;(a=r)!=null?a:r={assumption:()=>{}};const l=r.assumption("setPublicClassFields");const d=r.assumption("privateFieldsAsSymbols");const c=r.assumption("privateFieldsAsProperties");const p=r.assumption("constantSuper");const u=r.assumption("noDocumentAll");if(c&&d)throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');const f=c||d;if(s===true){const t=[];l!==void 0&&t.push('"setPublicClassFields"');c!==void 0&&t.push('"privateFieldsAsProperties"');d!==void 0&&t.push('"privateFieldsAsSymbols"');t.length!==0&&console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value for the ${t.join(" and ")} assumption${t.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsSymbols": true\n\t}`)}return{name:e,manipulateOptions:n,inherits:o,pre(e){(0,we.enableFeature)(e,t,s);typeof e.get(Ae)!=="number"&&e.get(Ae)&&!Ie.lt(e.get(Ae),"7.23.7")||e.set(Ae,"7.23.7")},visitor:{Class(e,{file:s}){var n;if(s.get(Ae)!=="7.23.7")return;if(!(0,we.shouldTransform)(e,s))return;const r=e.isClassDeclaration();r&&(0,Me.assertFieldTransformed)(e);const o=(0,we.isLoose)(s,t);let i;const a=(0,De.hasDecorators)(e.node);const y=[];const m=[];const h=[];const b=new Set;const v=e.get("body");for(const e of v.get("body")){(e.isClassProperty()||e.isClassMethod())&&e.node.computed&&h.push(e);if(e.isPrivate()){const{name:t}=e.node.key.id;const s=`get ${t}`;const n=`set ${t}`;if(e.isClassPrivateMethod()){if(e.node.kind==="get"){if(b.has(s)||b.has(t)&&!b.has(n))throw e.buildCodeFrameError("Duplicate private field");b.add(s).add(t)}else if(e.node.kind==="set"){if(b.has(n)||b.has(t)&&!b.has(s))throw e.buildCodeFrameError("Duplicate private field");b.add(n).add(t)}}else{if(b.has(t)&&!b.has(s)&&!b.has(n)||b.has(t)&&(b.has(s)||b.has(n)))throw e.buildCodeFrameError("Duplicate private field");b.add(t)}}if(e.isClassMethod({kind:"constructor"}))i=e;else{m.push(e);(e.isProperty()||e.isPrivate()||e.isStaticBlock!=null&&e.isStaticBlock())&&y.push(e)}}if(!y.length&&!a)return;const g=e.node.id;let P;if(!g||!r){(0,Ne.default)(e);P=e.scope.generateUidIdentifier("class")}const x=(n=P)!=null?n:Ce.types.cloneNode(g);const E=(0,Fe.buildPrivateNamesMap)(y);const C=(0,Fe.buildPrivateNamesNodes)(E,c!=null?c:o,d!=null&&d,s);(0,Fe.transformPrivateNamesUsage)(x,e,E,{privateFieldsAsProperties:f!=null?f:o,noDocumentAll:u,innerBinding:g},s);let N,k,S,I,F,D,$;if(a){k=F=N=[];({instanceNodes:S,wrapClass:$}=(0,De.buildDecoratedClass)(x,e,m,s))}else{N=(0,$e.extractComputedKeys)(e,h,s);({staticNodes:k,pureStaticNodes:F,instanceNodes:S,lastInstanceNodeReturnsThis:I,classBindingNode:D,wrapClass:$}=(0,Fe.buildFieldsInitNodes)(P,e.node.superClass,y,E,s,l!=null?l:o,f!=null?f:o,p!=null?p:o,g))}S.length>0&&(0,$e.injectInitialization)(e,i,S,((e,t)=>{if(!a)for(const s of y)Ce.types.isStaticBlock!=null&&Ce.types.isStaticBlock(s.node)||s.node.static||s.traverse(e,t)}),I);const w=$(e);w.insertBefore([...C,...N]);k.length>0&&w.insertAfter(k);F.length>0&&w.find((e=>e.isStatement()||e.isDeclaration())).insertAfter(F);D!=null&&r&&w.insertAfter(D)},ExportDefaultDeclaration(e,{file:t}){{if(t.get(Ae)!=="7.23.7")return;const s=e.get("declaration");s.isClassDeclaration()&&(0,De.hasDecorators)(s.node)&&(s.node.id?(0,ke.default)(e):s.node.type="ClassExpression")}}}}}const Le=Ee.__esModule,je=Ee.FEATURES,Te=Ee.buildCheckInRHS,Oe=Ee.enableFeature,Be=Ee.injectInitialization;const Ue=Ee.createClassFeaturePlugin;export{je as FEATURES,Le as __esModule,Te as buildCheckInRHS,Ue as createClassFeaturePlugin,Ee as default,Oe as enableFeature,Be as injectInitialization};

