var e={};Object.defineProperty(e,"__esModule",{value:true});e.findSuggestion=findSuggestion$1;const{min:t}=Math;function levenshtein(e,n){let o,r,i=[],a=[];const s=e.length,u=n.length;if(!s)return u;if(!u)return s;for(r=0;r<=u;r++)i[r]=r;for(o=1;o<=s;o++){for(a=[o],r=1;r<=u;r++)a[r]=e[o-1]===n[r-1]?i[r-1]:t(i[r-1],i[r],a[r-1])+1;i=a}return a[u]}function findSuggestion$1(e,n){const o=n.map((t=>levenshtein(t,e)));return n[o.indexOf(t(...o))]}var n={};Object.defineProperty(n,"__esModule",{value:true});n.OptionValidator=void 0;var o=e;let r=class OptionValidator{constructor(e){this.descriptor=e}validateTopLevelOptions(e,t){const n=Object.keys(t);for(const t of Object.keys(e))if(!n.includes(t))throw new Error(this.formatMessage(`'${t}' is not a valid top-level option.\n- Did you mean '${(0,o.findSuggestion)(t,n)}'?`))}validateBooleanOption(e,t,n){if(t===void 0)return n;this.invariant(typeof t==="boolean",`'${e}' option must be a boolean.`);return t}validateStringOption(e,t,n){if(t===void 0)return n;this.invariant(typeof t==="string",`'${e}' option must be a string.`);return t}invariant(e,t){if(!e)throw new Error(this.formatMessage(t))}formatMessage(e){return`${this.descriptor}: ${e}`}};n.OptionValidator=r;var i={};Object.defineProperty(i,"__esModule",{value:true});Object.defineProperty(i,"OptionValidator",{enumerable:true,get:function(){return a.OptionValidator}});Object.defineProperty(i,"findSuggestion",{enumerable:true,get:function(){return s.findSuggestion}});var a=n;var s=e;const u=i.__esModule,d=i.OptionValidator,f=i.findSuggestion;export{d as OptionValidator,u as __esModule,i as default,f as findSuggestion};

