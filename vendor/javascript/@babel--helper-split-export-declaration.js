import*as e from"@babel/types";var t="default"in e?e.default:e;var r={};Object.defineProperty(r,"__esModule",{value:true});r.default=splitExportDeclaration;var n=t;const{cloneNode:i,exportNamedDeclaration:a,exportSpecifier:o,identifier:s,variableDeclaration:l,variableDeclarator:c}=n;function splitExportDeclaration(e){if(!e.isExportDeclaration()||e.isExportAllDeclaration())throw new Error("Only default and named export declarations can be split.");if(e.isExportDefaultDeclaration()){const t=e.get("declaration");const r=t.isFunctionDeclaration()||t.isClassDeclaration();const n=t.isFunctionExpression()||t.isClassExpression();const d=t.isScope()?t.scope.parent:t.scope;let p=t.node.id;let f=false;if(p){if(n&&d.hasBinding(p.name)){f=true;p=d.generateUidIdentifier(p.name)}}else{f=true;p=d.generateUidIdentifier("default");(r||n)&&(t.node.id=i(p))}const u=r?t.node:l("var",[c(i(p),t.node)]);const x=a(null,[o(i(p),s("default"))]);e.insertAfter(x);e.replaceWith(u);f&&d.registerDeclaration(e);return e}if(e.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const t=e.get("declaration");const r=t.getOuterBindingIdentifiers();const n=Object.keys(r).map((e=>o(s(e),s(e))));const d=a(null,n);e.insertAfter(d);e.replaceWith(t.node);return e}const d=r.__esModule;export{d as __esModule,r as default};

