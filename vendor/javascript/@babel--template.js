import*as e from"@babel/types";import*as t from"@babel/parser";import*as r from"@babel/code-frame";var a="default"in e?e.default:e;var n={};Object.defineProperty(n,"__esModule",{value:true});n.statements=n.statement=n.smart=n.program=n.expression=void 0;var l=a;const{assertExpressionStatement:o}=l;function makeStatementFormatter(e){return{code:e=>`/* @babel/template */;\n${e}`,validate:()=>{},unwrap:t=>e(t.program.body.slice(1))}}const s=makeStatementFormatter((e=>e.length>1?e:e[0]));n.smart=s;const i=makeStatementFormatter((e=>e));n.statements=i;const c=makeStatementFormatter((e=>{if(0===e.length)throw new Error("Found nothing to return.");if(e.length>1)throw new Error("Found multiple statements but wanted one");return e[0]}));n.statement=c;const d={code:e=>`(\n${e}\n)`,validate:e=>{if(e.program.body.length>1)throw new Error("Found multiple statements but wanted one");if(0===d.unwrap(e).start)throw new Error("Parse result included parens.")},unwrap:({program:e})=>{const[t]=e.body;o(t);return t.expression}};n.expression=d;const p={code:e=>e,validate:()=>{},unwrap:e=>e.program};n.program=p;var u={};Object.defineProperty(u,"__esModule",{value:true});u.merge=merge;u.normalizeReplacements=normalizeReplacements;u.validate=validate$1;const m=["placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders"];function _objectWithoutPropertiesLoose(e,t){if(null==e)return{};var r={};var a=Object.keys(e);var n,l;for(l=0;l<a.length;l++){n=a[l];t.indexOf(n)>=0||(r[n]=e[n])}return r}function merge(e,t){const{placeholderWhitelist:r=e.placeholderWhitelist,placeholderPattern:a=e.placeholderPattern,preserveComments:n=e.preserveComments,syntacticPlaceholders:l=e.syntacticPlaceholders}=t;return{parser:Object.assign({},e.parser,t.parser),placeholderWhitelist:r,placeholderPattern:a,preserveComments:n,syntacticPlaceholders:l}}function validate$1(e){if(null!=e&&"object"!==typeof e)throw new Error("Unknown template options.");const t=e||{},{placeholderWhitelist:r,placeholderPattern:a,preserveComments:n,syntacticPlaceholders:l}=t,o=_objectWithoutPropertiesLoose(t,m);if(null!=r&&!(r instanceof Set))throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");if(null!=a&&!(a instanceof RegExp)&&false!==a)throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");if(null!=n&&"boolean"!==typeof n)throw new Error("'.preserveComments' must be a boolean, null, or undefined");if(null!=l&&"boolean"!==typeof l)throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");if(true===l&&(null!=r||null!=a))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");return{parser:o,placeholderWhitelist:r||void 0,placeholderPattern:null==a?void 0:a,preserveComments:null==n?void 0:n,syntacticPlaceholders:null==l?void 0:l}}function normalizeReplacements(e){if(Array.isArray(e))return e.reduce(((e,t,r)=>{e["$"+r]=t;return e}),{});if("object"===typeof e||null==e)return e||void 0;throw new Error("Template replacements must be an array, object, null, or undefined")}var h="default"in e?e.default:e;var f="default"in t?t.default:t;var y="default"in r?r.default:r;var v={};Object.defineProperty(v,"__esModule",{value:true});v.default=parseAndBuildMetadata;var w=h;var g=f;var b=y;const{isCallExpression:P,isExpressionStatement:E,isFunction:x,isIdentifier:j,isJSXIdentifier:A,isNewExpression:O,isPlaceholder:_,isStatement:S,isStringLiteral:W,removePropertiesDeep:k,traverse:$}=w;const C=/^[_$A-Z0-9]+$/;function parseAndBuildMetadata(e,t,r){const{placeholderWhitelist:a,placeholderPattern:n,preserveComments:l,syntacticPlaceholders:o}=r;const s=parseWithCodeFrame(t,r.parser,o);k(s,{preserveComments:l});e.validate(s);const i={syntactic:{placeholders:[],placeholderNames:new Set},legacy:{placeholders:[],placeholderNames:new Set},placeholderWhitelist:a,placeholderPattern:n,syntacticPlaceholders:o};$(s,placeholderVisitorHandler,i);return Object.assign({ast:s},i.syntactic.placeholders.length?i.syntactic:i.legacy)}function placeholderVisitorHandler(e,t,r){var a;let n;let l=r.syntactic.placeholders.length>0;if(_(e)){if(false===r.syntacticPlaceholders)throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");n=e.name.name;l=true}else{if(l||r.syntacticPlaceholders)return;if(j(e)||A(e))n=e.name;else{if(!W(e))return;n=e.value}}if(l&&(null!=r.placeholderPattern||null!=r.placeholderWhitelist))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");if(!l&&(false===r.placeholderPattern||!(r.placeholderPattern||C).test(n))&&!(null!=(a=r.placeholderWhitelist)&&a.has(n)))return;t=t.slice();const{node:o,key:s}=t[t.length-1];let i;if(W(e)||_(e,{expectedNode:"StringLiteral"}))i="string";else if(O(o)&&"arguments"===s||P(o)&&"arguments"===s||x(o)&&"params"===s)i="param";else if(E(o)&&!_(e)){i="statement";t=t.slice(0,-1)}else i=S(e)&&_(e)?"statement":"other";const{placeholders:c,placeholderNames:d}=l?r.syntactic:r.legacy;c.push({name:n,type:i,resolve:e=>resolveAncestors(e,t),isDuplicate:d.has(n)});d.add(n)}function resolveAncestors(e,t){let r=e;for(let e=0;e<t.length-1;e++){const{key:a,index:n}=t[e];r=void 0===n?r[a]:r[a][n]}const{key:a,index:n}=t[t.length-1];return{parent:r,key:a,index:n}}function parseWithCodeFrame(e,t,r){const a=(t.plugins||[]).slice();false!==r&&a.push("placeholders");t=Object.assign({allowReturnOutsideFunction:true,allowSuperOutsideMethod:true,sourceType:"module"},t,{plugins:a});try{return(0,g.parse)(e,t)}catch(t){const r=t.loc;if(r){t.message+="\n"+(0,b.codeFrameColumns)(e,{start:r});t.code="BABEL_TEMPLATE_PARSE_ERROR"}throw t}}var T="default"in e?e.default:e;var M={};Object.defineProperty(M,"__esModule",{value:true});M.default=populatePlaceholders;var R=T;const{blockStatement:F,cloneNode:L,emptyStatement:B,expressionStatement:N,identifier:U,isStatement:z,isStringLiteral:D,stringLiteral:I,validate:H}=R;function populatePlaceholders(e,t){const r=L(e.ast);if(t){e.placeholders.forEach((e=>{if(!Object.prototype.hasOwnProperty.call(t,e.name)){const t=e.name;throw new Error(`Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`)}}));Object.keys(t).forEach((t=>{if(!e.placeholderNames.has(t))throw new Error(`Unknown substitution "${t}" given`)}))}e.placeholders.slice().reverse().forEach((e=>{try{applyReplacement(e,r,t&&t[e.name]||null)}catch(t){t.message=`@babel/template placeholder "${e.name}": ${t.message}`;throw t}}));return r}function applyReplacement(e,t,r){e.isDuplicate&&(Array.isArray(r)?r=r.map((e=>L(e))):"object"===typeof r&&(r=L(r)));const{parent:a,key:n,index:l}=e.resolve(t);if("string"===e.type){"string"===typeof r&&(r=I(r));if(!r||!D(r))throw new Error("Expected string substitution")}else if("statement"===e.type){if(void 0===l)r?Array.isArray(r)?r=F(r):"string"===typeof r?r=N(U(r)):z(r)||(r=N(r)):r=B();else if(r&&!Array.isArray(r)){"string"===typeof r&&(r=U(r));z(r)||(r=N(r))}}else if("param"===e.type){"string"===typeof r&&(r=U(r));if(void 0===l)throw new Error("Assertion failure.")}else{"string"===typeof r&&(r=U(r));if(Array.isArray(r))throw new Error("Cannot replace single expression with an array.")}if(void 0===l){H(a,n,r);a[n]=r}else{const t=a[n].slice();"statement"===e.type||"param"===e.type?null==r?t.splice(l,1):Array.isArray(r)?t.splice(l,1,...r):t[l]=r:t[l]=r;H(a,n,t);a[n]=t}}var V={};Object.defineProperty(V,"__esModule",{value:true});V.default=stringTemplate;var J=u;var X=v;var Z=M;function stringTemplate(e,t,r){t=e.code(t);let a;return n=>{const l=(0,J.normalizeReplacements)(n);a||(a=(0,X.default)(e,t,r));return e.unwrap((0,Z.default)(a,l))}}var q={};Object.defineProperty(q,"__esModule",{value:true});q.default=literalTemplate;var G=u;var K=v;var Q=M;function literalTemplate(e,t,r){const{metadata:a,names:n}=buildLiteralData(e,t,r);return t=>{const r={};t.forEach(((e,t)=>{r[n[t]]=e}));return t=>{const n=(0,G.normalizeReplacements)(t);n&&Object.keys(n).forEach((e=>{if(Object.prototype.hasOwnProperty.call(r,e))throw new Error("Unexpected replacement overlap.")}));return e.unwrap((0,Q.default)(a,n?Object.assign(n,r):r))}}}function buildLiteralData(e,t,r){let a="BABEL_TPL$";const n=t.join("");do{a="$$"+a}while(n.includes(a));const{names:l,code:o}=buildTemplateCode(t,a);const s=(0,K.default)(e,e.code(o),{parser:r.parser,placeholderWhitelist:new Set(l.concat(r.placeholderWhitelist?Array.from(r.placeholderWhitelist):[])),placeholderPattern:r.placeholderPattern,preserveComments:r.preserveComments,syntacticPlaceholders:r.syntacticPlaceholders});return{metadata:s,names:l}}function buildTemplateCode(e,t){const r=[];let a=e[0];for(let n=1;n<e.length;n++){const l=`${t}${n-1}`;r.push(l);a+=l+e[n]}return{names:r,code:a}}var Y={};Object.defineProperty(Y,"__esModule",{value:true});Y.default=createTemplateBuilder;var ee=u;var te=V;var re=q;const ae=(0,ee.validate)({placeholderPattern:false});function createTemplateBuilder(e,t){const r=new WeakMap;const a=new WeakMap;const n=t||(0,ee.validate)(null);return Object.assign(((t,...a)=>{if("string"===typeof t){if(a.length>1)throw new Error("Unexpected extra params.");return extendedTrace((0,te.default)(e,t,(0,ee.merge)(n,(0,ee.validate)(a[0]))))}if(Array.isArray(t)){let l=r.get(t);if(!l){l=(0,re.default)(e,t,n);r.set(t,l)}return extendedTrace(l(a))}if("object"===typeof t&&t){if(a.length>0)throw new Error("Unexpected extra params.");return createTemplateBuilder(e,(0,ee.merge)(n,(0,ee.validate)(t)))}throw new Error("Unexpected template param "+typeof t)}),{ast:(t,...r)=>{if("string"===typeof t){if(r.length>1)throw new Error("Unexpected extra params.");return(0,te.default)(e,t,(0,ee.merge)((0,ee.merge)(n,(0,ee.validate)(r[0])),ae))()}if(Array.isArray(t)){let l=a.get(t);if(!l){l=(0,re.default)(e,t,(0,ee.merge)(n,ae));a.set(t,l)}return l(r)()}throw new Error("Unexpected template param "+typeof t)}})}function extendedTrace(e){let t="";try{throw new Error}catch(e){e.stack&&(t=e.stack.split("\n").slice(3).join("\n"))}return r=>{try{return e(r)}catch(e){e.stack+=`\n    =============\n${t}`;throw e}}}var ne={};Object.defineProperty(ne,"__esModule",{value:true});ne.statements=ne.statement=ne.smart=ne.program=ne.expression=ne.default=void 0;var le=n;var oe=Y;const se=(0,oe.default)(le.smart);ne.smart=se;const ie=(0,oe.default)(le.statement);ne.statement=ie;const ce=(0,oe.default)(le.statements);ne.statements=ce;const de=(0,oe.default)(le.expression);ne.expression=de;const pe=(0,oe.default)(le.program);ne.program=pe;var ue=Object.assign(se.bind(void 0),{smart:se,statement:ie,statements:ce,expression:de,program:pe,ast:se.ast});ne.default=ue;const me=ne.__esModule;const he=ne.statements,fe=ne.statement,ye=ne.smart,ve=ne.program,we=ne.expression;export{me as __esModule,ne as default,we as expression,ve as program,ye as smart,fe as statement,he as statements};

