import*as e from"@babel/helper-environment-visitor";import*as t from"@babel/helper-member-expression-to-functions";import*as s from"@babel/helper-optimise-call-expression";import*as r from"@babel/core";var i="default"in e?e.default:e;var o="default"in t?t.default:t;var n="default"in s?s.default:s;var p="default"in r?r.default:r;var a={};Object.defineProperty(a,"__esModule",{value:true});a.default=void 0;var c=i;var h=o;var u=n;var l=p;const{assignmentExpression:d,booleanLiteral:f,callExpression:m,cloneNode:g,identifier:v,memberExpression:b,sequenceExpression:R,stringLiteral:S,thisExpression:y}=l.types;{const e=i;a.environmentVisitor=e.default;a.skipAllButComputedKey=e.skipAllButComputedKey}function getPrototypeOfExpression(e,t,s,r){e=g(e);const i=t||r?e:b(e,v("prototype"));return m(s.addHelper("getPrototypeOf"),[i])}const P=l.traverse.visitors.merge([c.default,{Super(e,t){const{node:s,parentPath:r}=e;r.isMemberExpression({object:s})&&t.handle(r)}}]);const O=l.traverse.visitors.merge([c.default,{Scopable(e,{refName:t}){const s=e.scope.getOwnBinding(t);s&&s.identifier.name===t&&e.scope.rename(t)}}]);const x={memoise(e,t){const{scope:s,node:r}=e;const{computed:i,property:o}=r;if(!i)return;const n=s.maybeGenerateMemoised(o);n&&this.memoiser.set(o,n,t)},prop(e){const{computed:t,property:s}=e.node;return this.memoiser.has(s)?g(this.memoiser.get(s)):t?g(s):S(s.name)},get(e){return this._get(e,this._getThisRefs())},_get(e,t){const s=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return m(this.file.addHelper("get"),[t.memo?R([t.memo,s]):s,this.prop(e),t.this])},_getThisRefs(){if(!this.isDerivedConstructor)return{this:y()};const e=this.scope.generateDeclaredUidIdentifier("thisSuper");return{memo:d("=",e,y()),this:g(e)}},set(e,t){const s=this._getThisRefs();const r=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return m(this.file.addHelper("set"),[s.memo?R([s.memo,r]):r,this.prop(e),t,s.this,f(e.isInStrictMode())])},destructureSet(e){throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(e,t){const s=this._getThisRefs();return(0,u.default)(this._get(e,s),g(s.this),t,false)},optionalCall(e,t){const s=this._getThisRefs();return(0,u.default)(this._get(e,s),g(s.this),t,true)},delete(e){return e.node.computed?R([m(this.file.addHelper("toPropertyKey"),[g(e.node.property)]),l.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]):l.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `}};const j=Object.assign({},x,{prop(e){const{property:t}=e.node;return this.memoiser.has(t)?g(this.memoiser.get(t)):g(t)},get(e){const{isStatic:t,getSuperRef:s}=this;const{computed:r}=e.node;const i=this.prop(e);let o;if(t){var n;o=null!=(n=s())?n:b(v("Function"),v("prototype"))}else{var p;o=b(null!=(p=s())?p:v("Object"),v("prototype"))}return b(o,i,r)},set(e,t){const{computed:s}=e.node;const r=this.prop(e);return d("=",b(y(),r,s),t)},destructureSet(e){const{computed:t}=e.node;const s=this.prop(e);return b(y(),s,t)},call(e,t){return(0,u.default)(this.get(e),y(),t,false)},optionalCall(e,t){return(0,u.default)(this.get(e),y(),t,true)}});class ReplaceSupers{constructor(e){var t;const s=e.methodPath;this.methodPath=s;this.isDerivedConstructor=s.isClassMethod({kind:"constructor"})&&!!e.superRef;this.isStatic=s.isObjectMethod()||s.node.static||(null==s.isStaticBlock?void 0:s.isStaticBlock());this.isPrivateMethod=s.isPrivate()&&s.isMethod();this.file=e.file;this.constantSuper=null!=(t=e.constantSuper)?t:e.isLoose;this.opts=e}getObjectRef(){return g(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){return this.opts.superRef?g(this.opts.superRef):this.opts.getSuperRef?g(this.opts.getSuperRef()):void 0}replace(){this.opts.refToPreserve&&this.methodPath.traverse(O,{refName:this.opts.refToPreserve.name});const e=this.constantSuper?j:x;(0,h.default)(this.methodPath,P,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:e.get},e))}}a.default=ReplaceSupers;const M=a.__esModule,_=a.environmentVisitor,E=a.skipAllButComputedKey;export{M as __esModule,a as default,_ as environmentVisitor,E as skipAllButComputedKey};

