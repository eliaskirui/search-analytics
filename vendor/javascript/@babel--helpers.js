import*as e from"@babel/traverse";import*as t from"@babel/types";import n from"./helpers.js";import"@babel/template";var r=e;try{"default"in e&&(r=e.default)}catch(e){}var o=t;try{"default"in t&&(o=t.default)}catch(e){}var a={};Object.defineProperty(a,"__esModule",{value:true});a.default=void 0;a.ensure=ensure;a.get=get;a.getDependencies=getDependencies;a.list=void 0;a.minVersion=minVersion;var s=r;var i=o;var l=n;const{assignmentExpression:c,cloneNode:p,expressionStatement:d,file:f,identifier:u}=i;function makePath(e){const t=[];for(;e.parentPath;e=e.parentPath){t.push(e.key);e.inList&&t.push(e.listKey)}return t.reverse().join(".")}let m;function getHelperMetadata(e){const t=new Set;const n=new Set;const r=new Map;let o;let a;const i=[];const c=[];const p=[];const d={ImportDeclaration(e){const t=e.node.source.value;if(!l.default[t])throw e.buildCodeFrameError(`Unknown helper ${t}`);if(e.get("specifiers").length!==1||!e.get("specifiers.0").isImportDefaultSpecifier())throw e.buildCodeFrameError("Helpers can only import a default value");const n=e.node.specifiers[0].local;r.set(n,t);c.push(makePath(e))},ExportDefaultDeclaration(e){const t=e.get("declaration");if(!t.isFunctionDeclaration()||!t.node.id)throw t.buildCodeFrameError("Helpers can only export named function declarations");o=t.node.id.name;a=makePath(e)},ExportAllDeclaration(e){throw e.buildCodeFrameError("Helpers can only export default")},ExportNamedDeclaration(e){throw e.buildCodeFrameError("Helpers can only export default")},Statement(e){e.isImportDeclaration()||e.isExportDeclaration()||e.skip()}};const f={Program(e){const t=e.scope.getAllBindings();Object.keys(t).forEach((e=>{e!==o&&(r.has(t[e].identifier)||n.add(e))}))},ReferencedIdentifier(e){const n=e.node.name;const o=e.scope.getBinding(n);o?r.has(o.identifier)&&p.push(makePath(e)):t.add(n)},AssignmentExpression(e){const t=e.get("left");if(!(o in t.getBindingIdentifiers()))return;if(!t.isIdentifier())throw t.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");const n=e.scope.getBinding(o);n!=null&&n.scope.path.isProgram()&&i.push(makePath(e))}};(0,s.default)(e.ast,d,e.scope);(0,s.default)(e.ast,f,e.scope);if(!a)throw new Error("Helpers must have a default export.");i.reverse();return{globals:Array.from(t),localBindingNames:Array.from(n),dependencies:r,exportBindingAssignments:i,exportPath:a,exportName:o,importBindingsReferences:p,importPaths:c}}function permuteHelperAST(e,t,n,r,o){if(r&&!n)throw new Error("Unexpected local bindings for module-based helpers.");if(!n)return;const{localBindingNames:a,dependencies:s,exportBindingAssignments:i,exportPath:l,exportName:f,importBindingsReferences:m,importPaths:h}=t;const g={};s.forEach(((e,t)=>{g[t.name]=typeof o==="function"&&o(e)||t}));const b={};const E=new Set(r||[]);n.type==="Identifier"&&E.add(n.name);a.forEach((e=>{let t=e;while(E.has(t))t="_"+t;t!==e&&(b[e]=t)}));n.type==="Identifier"&&f!==n.name&&(b[f]=n.name);const{path:y}=e;const w=y.get(l);const x=h.map((e=>y.get(e)));const v=m.map((e=>y.get(e)));const D=w.get("declaration");if(n.type==="Identifier")w.replaceWith(D);else{if(n.type!=="MemberExpression")throw new Error("Unexpected helper format.");i.forEach((e=>{const t=y.get(e);t.replaceWith(c("=",n,t.node))}));w.replaceWith(D);y.pushContainer("body",d(c("=",n,u(f))))}Object.keys(b).forEach((e=>{y.scope.rename(e,b[e])}));for(const e of x)e.remove();for(const e of v){const t=p(g[e.node.name]);e.replaceWith(t)}}const h=Object.create(null);function loadHelper(e){if(!h[e]){const t=l.default[e];if(!t)throw Object.assign(new ReferenceError(`Unknown helper ${e}`),{code:"BABEL_HELPER_UNKNOWN",helper:e});const fn=()=>{if(!m){const e={ast:f(t.ast()),path:null};(0,s.default)(e.ast,{Program:t=>(e.path=t).stop()});return e}return new m({filename:`babel-helper://${e}`},{ast:f(t.ast()),code:"[internal Babel helper code]",inputMap:null})};let n=null;h[e]={minVersion:t.minVersion,build(e,t,r){const o=fn();n||(n=getHelperMetadata(o));permuteHelperAST(o,n,t,r,e);return{nodes:o.ast.program.body,globals:n.globals}},getDependencies(){n||(n=getHelperMetadata(fn()));return Array.from(n.dependencies.values())}}}return h[e]}function get(e,t,n,r){return loadHelper(e).build(t,n,r)}function minVersion(e){return loadHelper(e).minVersion}function getDependencies(e){return loadHelper(e).getDependencies()}function ensure(e,t){m||(m=t);loadHelper(e)}a.list=Object.keys(l.default).map((e=>e.replace(/^_/,"")));a.default=get;const g=a.__esModule;const b=a.ensure,E=a.get,y=a.getDependencies,w=a.list,x=a.minVersion;export{g as __esModule,a as default,b as ensure,E as get,y as getDependencies,w as list,x as minVersion};

