import*as e from"@babel/template";import*as n from"@babel/types";var t="default"in e?e.default:e;var r="default"in n?n.default:n;var i={};Object.defineProperty(i,"__esModule",{value:true});i.default=_default;var a=t;var s=r;const{NOT_LOCAL_BINDING:o,cloneNode:f,identifier:u,isAssignmentExpression:l,isAssignmentPattern:d,isFunction:c,isIdentifier:N,isLiteral:m,isNullLiteral:I,isObjectMethod:g,isObjectProperty:p,isRegExpLiteral:F,isRestElement:_,isTemplateLiteral:O,isVariableDeclarator:T,toBindingIdentifierName:U}=s;function getFunctionArity(e){const n=e.params.findIndex((e=>d(e)||_(e)));return-1===n?e.params.length:n}const C=a.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");const v=a.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");const D={"ReferencedIdentifier|BindingIdentifier"(e,n){if(e.node.name!==n.name)return;const t=e.scope.getBindingIdentifier(n.name);if(t===n.outerDeclar){n.selfReference=true;e.stop()}}};function getNameFromLiteralId(e){return I(e)?"null":F(e)?`_${e.pattern}_${e.flags}`:O(e)?e.quasis.map((e=>e.value.raw)).join(""):void 0!==e.value?e.value+"":""}function wrap(e,n,t,r){if(e.selfReference){if(!r.hasBinding(t.name)||r.hasGlobal(t.name)){if(!c(n))return;let e=C;n.generator&&(e=v);const i=e({FUNCTION:n,FUNCTION_ID:t,FUNCTION_KEY:r.generateUidIdentifier(t.name)}).expression;const a=i.callee.body.body[0].params;for(let e=0,t=getFunctionArity(n);e<t;e++)a.push(r.generateUidIdentifier("x"));return i}r.rename(t.name)}n.id=t;r.getProgramParent().references[t.name]=true}function visit(e,n,t){const r={selfAssignment:false,selfReference:false,outerDeclar:t.getBindingIdentifier(n),name:n};const i=t.getOwnBinding(n);i?"param"===i.kind&&(r.selfReference=true):(r.outerDeclar||t.hasGlobal(n))&&t.traverse(e,D,r);return r}function _default({node:e,parent:n,scope:t,id:r},i=false,a=false){if(e.id)return;if(!p(n)&&!g(n,{kind:"method"})||n.computed&&!m(n.key)){if(T(n)){r=n.id;if(N(r)&&!i){const n=t.parent.getBinding(r.name);if(n&&n.constant&&t.getBinding(r.name)===n){e.id=f(r);e.id[o]=true;return}}}else if(l(n,{operator:"="}))r=n.left;else if(!r)return}else r=n.key;let s;r&&m(r)?s=getNameFromLiteralId(r):r&&N(r)&&(s=r.name);if(void 0===s)return;if(!a&&c(e)&&/[\uD800-\uDFFF]/.test(s))return;s=U(s);const d=u(s);d[o]=true;const I=visit(e,s,t);return wrap(I,e,d,t)||e}const b=i.__esModule;export{b as __esModule,i as default};

