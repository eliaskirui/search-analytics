var e={};const t=Symbol.for("gensync:v1:start");const n=Symbol.for("gensync:v1:suspend");const r="GENSYNC_EXPECTED_START";const a="GENSYNC_EXPECTED_SUSPEND";const o="GENSYNC_OPTIONS_ERROR";const c="GENSYNC_RACE_NONEMPTY";const s="GENSYNC_ERRBACK_NO_CALLBACK";e=Object.assign((function gensync(e){let t=e;t="function"!==typeof e?newGenerator(e):wrapGenerator(e);return Object.assign(t,makeFunctionAPI(t))}),{all:buildOperation({name:"all",arity:1,sync:function(e){const t=Array.from(e[0]);return t.map((e=>evaluateSync(e)))},async:function(e,t,n){const r=Array.from(e[0]);if(0===r.length){Promise.resolve().then((()=>t([])));return}let a=0;const o=r.map((()=>{}));r.forEach(((e,r)=>{evaluateAsync(e,(e=>{o[r]=e;a+=1;a===o.length&&t(o)}),n)}))}}),race:buildOperation({name:"race",arity:1,sync:function(e){const t=Array.from(e[0]);if(0===t.length)throw makeError("Must race at least 1 item",c);return evaluateSync(t[0])},async:function(e,t,n){const r=Array.from(e[0]);if(0===r.length)throw makeError("Must race at least 1 item",c);for(const e of r)evaluateAsync(e,t,n)}})});function makeFunctionAPI(e){const t={sync:function(...t){return evaluateSync(e.apply(this,t))},async:function(...t){return new Promise(((n,r)=>{evaluateAsync(e.apply(this,t),n,r)}))},errback:function(...t){const n=t.pop();if("function"!==typeof n)throw makeError("Asynchronous function called without callback",s);let r;try{r=e.apply(this,t)}catch(e){n(e);return}evaluateAsync(r,(e=>n(void 0,e)),(e=>n(e)))}};return t}function assertTypeof(e,t,n,r){if(typeof n===e||r&&"undefined"===typeof n)return;let a;a=r?`Expected opts.${t} to be either a ${e}, or undefined.`:`Expected opts.${t} to be a ${e}.`;throw makeError(a,o)}function makeError(e,t){return Object.assign(new Error(e),{code:t})}function newGenerator({name:e,arity:t,sync:n,async:r,errback:a}){assertTypeof("string","name",e,true);assertTypeof("number","arity",t,true);assertTypeof("function","sync",n);assertTypeof("function","async",r,true);assertTypeof("function","errback",a,true);if(r&&a)throw makeError("Expected one of either opts.async or opts.errback, but got _both_.",o);if("string"!==typeof e){let t;a&&a.name&&"errback"!==a.name&&(t=a.name);r&&r.name&&"async"!==r.name&&(t=r.name.replace(/Async$/,""));n&&n.name&&"sync"!==n.name&&(t=n.name.replace(/Sync$/,""));"string"===typeof t&&(e=t)}"number"!==typeof t&&(t=n.length);return buildOperation({name:e,arity:t,sync:function(e){return n.apply(this,e)},async:function(e,t,o){r?r.apply(this,e).then(t,o):a?a.call(this,...e,((e,n)=>{null==e?t(n):o(e)})):t(n.apply(this,e))}})}function wrapGenerator(e){return setFunctionMetadata(e.name,e.length,(function(...t){return e.apply(this,t)}))}function buildOperation({name:e,arity:r,sync:a,async:o}){return setFunctionMetadata(e,r,(function*(...e){const r=yield t;if(!r){const t=a.call(this,e);return t}let c;try{o.call(this,e,(e=>{if(!c){c={value:e};r()}}),(e=>{if(!c){c={err:e};r()}}))}catch(e){c={err:e};r()}yield n;if(c.hasOwnProperty("err"))throw c.err;return c.value}))}function evaluateSync(e){let t;while(!({value:t}=e.next()).done)assertStart(t,e);return t}function evaluateAsync(e,t,n){(function step(){try{let n;while(!({value:n}=e.next()).done){assertStart(n,e);let t=true;let r=false;const a=e.next((()=>{t?r=true:step()}));t=false;assertSuspend(a,e);if(!r)return}return t(n)}catch(e){return n(e)}})()}function assertStart(e,n){e!==t&&throwError(n,makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,r))}function assertSuspend({value:e,done:t},r){(t||e!==n)&&throwError(r,makeError(t?"Unexpected generator completion. If you get this, it is probably a gensync bug.":`Expected GENSYNC_SUSPEND, got ${JSON.stringify(e)}. If you get this, it is probably a gensync bug.`,a))}function throwError(e,t){e.throw&&e.throw(t);throw t}function isIterable(e){return!!e&&("object"===typeof e||"function"===typeof e)&&!e[Symbol.iterator]}function setFunctionMetadata(e,t,n){if("string"===typeof e){const t=Object.getOwnPropertyDescriptor(n,"name");t&&!t.configurable||Object.defineProperty(n,"name",Object.assign(t||{},{configurable:true,value:e}))}if("number"===typeof t){const e=Object.getOwnPropertyDescriptor(n,"length");e&&!e.configurable||Object.defineProperty(n,"length",Object.assign(e||{},{configurable:true,value:t}))}return n}var i=e;export default i;

