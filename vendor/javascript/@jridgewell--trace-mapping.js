import*as e from"@jridgewell/sourcemap-codec";import*as n from"@jridgewell/resolve-uri";var t=e;try{"default"in e&&(t=e.default)}catch(e){}var o=n;try{"default"in n&&(o=n.default)}catch(e){}var r={};(function(e,n){n(r,t,o)})(0,(function(e,n,t){function resolve(e,n){n&&!n.endsWith("/")&&(n+="/");return t(e,n)}function stripFilename(e){if(!e)return"";const n=e.lastIndexOf("/");return e.slice(0,n+1)}const o=0;const r=1;const s=2;const c=3;const i=4;const l=1;const u=2;function maybeSort(e,n){const t=nextUnsortedSegmentLine(e,0);if(t===e.length)return e;n||(e=e.slice());for(let o=t;o<e.length;o=nextUnsortedSegmentLine(e,o+1))e[o]=sortSegments(e[o],n);return e}function nextUnsortedSegmentLine(e,n){for(let t=n;t<e.length;t++)if(!isSorted(e[t]))return t;return e.length}function isSorted(e){for(let n=1;n<e.length;n++)if(e[n][o]<e[n-1][o])return false;return true}function sortSegments(e,n){n||(e=e.slice());return e.sort(sortComparator)}function sortComparator(e,n){return e[o]-n[o]}let d=false;function binarySearch(e,n,t,r){while(t<=r){const s=t+(r-t>>1);const c=e[s][o]-n;if(c===0){d=true;return s}c<0?t=s+1:r=s-1}d=false;return t-1}function upperBound(e,n,t){for(let r=t+1;r<e.length;t=r++)if(e[r][o]!==n)break;return t}function lowerBound(e,n,t){for(let r=t-1;r>=0;t=r--)if(e[r][o]!==n)break;return t}function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}function memoizedBinarySearch(e,n,t,r){const{lastKey:s,lastNeedle:c,lastIndex:i}=t;let l=0;let u=e.length-1;if(r===s){if(n===c){d=i!==-1&&e[i][o]===n;return i}n>=c?l=i===-1?0:i:u=i}t.lastKey=r;t.lastNeedle=n;return t.lastIndex=binarySearch(e,n,l,u)}function buildBySources(e,n){const t=n.map(buildNullArray);for(let i=0;i<e.length;i++){const l=e[i];for(let e=0;e<l.length;e++){const u=l[e];if(u.length===1)continue;const d=u[r];const a=u[s];const p=u[c];const f=t[d];const g=f[a]||(f[a]=[]);const m=n[d];const h=upperBound(g,p,memoizedBinarySearch(g,p,m,a));insert(g,m.lastIndex=h+1,[p,i,u[o]])}}return t}function insert(e,n,t){for(let t=e.length;t>n;t--)e[t]=e[t-1];e[n]=t}function buildNullArray(){return{__proto__:null}}const AnyMap=function(n,t){const o=typeof n==="string"?JSON.parse(n):n;if(!("sections"in o))return new TraceMap(o,t);const r=[];const s=[];const c=[];const i=[];recurse(o,t,r,s,c,i,0,0,Infinity,Infinity);const l={version:3,file:o.file,names:i,sources:s,sourcesContent:c,mappings:r};return e.presortedDecodedMap(l)};function recurse(e,n,t,o,r,s,c,i,l,u){const{sections:d}=e;for(let e=0;e<d.length;e++){const{map:a,offset:p}=d[e];let f=l;let g=u;if(e+1<d.length){const n=d[e+1].offset;f=Math.min(l,c+n.line);f===l?g=Math.min(u,i+n.column):f<l&&(g=i+n.column)}addSection(a,n,t,o,r,s,c+p.line,i+p.column,f,g)}}function addSection(n,t,l,u,d,a,p,f,g,m){if("sections"in n)return recurse(...arguments);const h=new TraceMap(n,t);const M=u.length;const S=a.length;const v=e.decodedMappings(h);const{resolvedSources:_,sourcesContent:y}=h;append(u,_);append(a,h.names);if(y)append(d,y);else for(let e=0;e<_.length;e++)d.push(null);for(let e=0;e<v.length;e++){const n=p+e;if(n>g)return;const t=getLine(l,n);const u=e===0?f:0;const d=v[e];for(let e=0;e<d.length;e++){const l=d[e];const a=u+l[o];if(n===g&&a>=m)return;if(l.length===1){t.push([a]);continue}const p=M+l[r];const f=l[s];const h=l[c];t.push(l.length===4?[a,p,f,h]:[a,p,f,h,S+l[i]])}}}function append(e,n){for(let t=0;t<n.length;t++)e.push(n[t])}function getLine(e,n){for(let t=e.length;t<=n;t++)e[t]=[];return e[n]}const a="`line` must be greater than 0 (lines start at line 1)";const p="`column` must be greater than or equal to 0 (columns start at column 0)";const f=-1;const g=1;e.encodedMappings=void 0;e.decodedMappings=void 0;e.traceSegment=void 0;e.originalPositionFor=void 0;e.generatedPositionFor=void 0;e.allGeneratedPositionsFor=void 0;e.eachMapping=void 0;e.sourceContentFor=void 0;e.presortedDecodedMap=void 0;e.decodedMap=void 0;e.encodedMap=void 0;class TraceMap{constructor(e,n){const t=typeof e==="string";if(!t&&e._decodedMemo)return e;const o=t?JSON.parse(e):e;const{version:r,file:s,names:c,sourceRoot:i,sources:l,sourcesContent:u}=o;this.version=r;this.file=s;this.names=c||[];this.sourceRoot=i;this.sources=l;this.sourcesContent=u;const d=resolve(i||"",stripFilename(n));this.resolvedSources=l.map((e=>resolve(e||"",d)));const{mappings:a}=o;if(typeof a==="string"){this._encoded=a;this._decoded=void 0}else{this._encoded=void 0;this._decoded=maybeSort(a,t)}this._decodedMemo=memoizedState();this._bySources=void 0;this._bySourceMemos=void 0}}(()=>{e.encodedMappings=e=>{var t;return(t=e._encoded)!==null&&t!==void 0?t:e._encoded=n.encode(e._decoded)};e.decodedMappings=e=>e._decoded||(e._decoded=n.decode(e._encoded));e.traceSegment=(n,t,o)=>{const r=e.decodedMappings(n);if(t>=r.length)return null;const s=r[t];const c=traceSegmentInternal(s,n._decodedMemo,t,o,g);return c===-1?null:s[c]};e.originalPositionFor=(n,{line:t,column:o,bias:l})=>{t--;if(t<0)throw new Error(a);if(o<0)throw new Error(p);const u=e.decodedMappings(n);if(t>=u.length)return OMapping(null,null,null,null);const d=u[t];const f=traceSegmentInternal(d,n._decodedMemo,t,o,l||g);if(f===-1)return OMapping(null,null,null,null);const m=d[f];if(m.length===1)return OMapping(null,null,null,null);const{names:h,resolvedSources:M}=n;return OMapping(M[m[r]],m[s]+1,m[c],m.length===5?h[m[i]]:null)};e.allGeneratedPositionsFor=(e,{source:n,line:t,column:o,bias:r})=>generatedPosition(e,n,t,o,r||f,true);e.generatedPositionFor=(e,{source:n,line:t,column:o,bias:r})=>generatedPosition(e,n,t,o,r||g,false);e.eachMapping=(n,t)=>{const o=e.decodedMappings(n);const{names:r,resolvedSources:s}=n;for(let e=0;e<o.length;e++){const n=o[e];for(let o=0;o<n.length;o++){const c=n[o];const i=e+1;const l=c[0];let u=null;let d=null;let a=null;let p=null;if(c.length!==1){u=s[c[1]];d=c[2]+1;a=c[3]}c.length===5&&(p=r[c[4]]);t({generatedLine:i,generatedColumn:l,source:u,originalLine:d,originalColumn:a,name:p})}}};e.sourceContentFor=(e,n)=>{const{sources:t,resolvedSources:o,sourcesContent:r}=e;if(r==null)return null;let s=t.indexOf(n);s===-1&&(s=o.indexOf(n));return s===-1?null:r[s]};e.presortedDecodedMap=(e,n)=>{const t=new TraceMap(clone(e,[]),n);t._decoded=e.mappings;return t};e.decodedMap=n=>clone(n,e.decodedMappings(n));e.encodedMap=n=>clone(n,e.encodedMappings(n));function generatedPosition(n,t,o,r,s,c){o--;if(o<0)throw new Error(a);if(r<0)throw new Error(p);const{sources:i,resolvedSources:d}=n;let f=i.indexOf(t);f===-1&&(f=d.indexOf(t));if(f===-1)return c?[]:GMapping(null,null);const g=n._bySources||(n._bySources=buildBySources(e.decodedMappings(n),n._bySourceMemos=i.map(memoizedState)));const m=g[f][o];if(m==null)return c?[]:GMapping(null,null);const h=n._bySourceMemos[f];if(c)return sliceGeneratedPositions(m,h,o,r,s);const M=traceSegmentInternal(m,h,o,r,s);if(M===-1)return GMapping(null,null);const S=m[M];return GMapping(S[l]+1,S[u])}})();function clone(e,n){return{version:e.version,file:e.file,names:e.names,sourceRoot:e.sourceRoot,sources:e.sources,sourcesContent:e.sourcesContent,mappings:n}}function OMapping(e,n,t,o){return{source:e,line:n,column:t,name:o}}function GMapping(e,n){return{line:e,column:n}}function traceSegmentInternal(e,n,t,o,r){let s=memoizedBinarySearch(e,o,n,t);d?s=(r===f?upperBound:lowerBound)(e,o,s):r===f&&s++;return s===-1||s===e.length?-1:s}function sliceGeneratedPositions(e,n,t,r,s){let c=traceSegmentInternal(e,n,t,r,g);d||s!==f||c++;if(c===-1||c===e.length)return[];const i=d?r:e[c][o];d||(c=lowerBound(e,i,c));const a=upperBound(e,i,c);const p=[];for(;c<=a;c++){const n=e[c];p.push(GMapping(n[l]+1,n[u]))}return p}e.AnyMap=AnyMap;e.GREATEST_LOWER_BOUND=g;e.LEAST_UPPER_BOUND=f;e.TraceMap=TraceMap}));const s=r.encodedMappings,c=r.decodedMappings,i=r.traceSegment,l=r.originalPositionFor,u=r.generatedPositionFor,d=r.allGeneratedPositionsFor,a=r.eachMapping,p=r.sourceContentFor,f=r.presortedDecodedMap,g=r.decodedMap,m=r.encodedMap,h=r.AnyMap,M=r.GREATEST_LOWER_BOUND,S=r.LEAST_UPPER_BOUND,v=r.TraceMap;export{h as AnyMap,M as GREATEST_LOWER_BOUND,S as LEAST_UPPER_BOUND,v as TraceMap,d as allGeneratedPositionsFor,g as decodedMap,c as decodedMappings,r as default,a as eachMapping,m as encodedMap,s as encodedMappings,u as generatedPositionFor,l as originalPositionFor,f as presortedDecodedMap,p as sourceContentFor,i as traceSegment};

