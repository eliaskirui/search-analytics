import t from"yallist";var e={};const s=t;const n=Symbol("max");const i=Symbol("length");const h=Symbol("lengthCalculator");const r=Symbol("allowStale");const o=Symbol("maxAge");const a=Symbol("dispose");const l=Symbol("noDisposeOnSet");const u=Symbol("lruList");const m=Symbol("cache");const c=Symbol("updateAgeOnGet");const naiveLength=()=>1;class LRUCache{constructor(t){"number"===typeof t&&(t={max:t});t||(t={});if(t.max&&("number"!==typeof t.max||t.max<0))throw new TypeError("max must be a non-negative number");const e=this[n]=t.max||Infinity;const s=t.length||naiveLength;this[h]="function"!==typeof s?naiveLength:s;this[r]=t.stale||false;if(t.maxAge&&"number"!==typeof t.maxAge)throw new TypeError("maxAge must be a number");this[o]=t.maxAge||0;this[a]=t.dispose;this[l]=t.noDisposeOnSet||false;this[c]=t.updateAgeOnGet||false;this.reset()}set max(t){if("number"!==typeof t||t<0)throw new TypeError("max must be a non-negative number");this[n]=t||Infinity;trim(this)}get max(){return this[n]}set allowStale(t){this[r]=!!t}get allowStale(){return this[r]}set maxAge(t){if("number"!==typeof t)throw new TypeError("maxAge must be a non-negative number");this[o]=t;trim(this)}get maxAge(){return this[o]}set lengthCalculator(t){"function"!==typeof t&&(t=naiveLength);if(t!==this[h]){this[h]=t;this[i]=0;this[u].forEach(t=>{t.length=this[h](t.value,t.key);this[i]+=t.length})}trim(this)}get lengthCalculator(){return this[h]}get length(){return this[i]}get itemCount(){return this[u].length}rforEach(t,e){e=e||this;for(let s=this[u].tail;null!==s;){const n=s.prev;forEachStep(this,t,s,e);s=n}}forEach(t,e){e=e||this;for(let s=this[u].head;null!==s;){const n=s.next;forEachStep(this,t,s,e);s=n}}keys(){return this[u].toArray().map(t=>t.key)}values(){return this[u].toArray().map(t=>t.value)}reset(){this[a]&&this[u]&&this[u].length&&this[u].forEach(t=>this[a](t.key,t.value));this[m]=new Map;this[u]=new s;this[i]=0}dump(){return this[u].map(t=>!isStale(this,t)&&{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[u]}set(t,e,s){s=s||this[o];if(s&&"number"!==typeof s)throw new TypeError("maxAge must be a number");const r=s?Date.now():0;const c=this[h](e,t);if(this[m].has(t)){if(c>this[n]){del(this,this[m].get(t));return false}const h=this[m].get(t);const o=h.value;this[a]&&(this[l]||this[a](t,o.value));o.now=r;o.maxAge=s;o.value=e;this[i]+=c-o.length;o.length=c;this.get(t);trim(this);return true}const f=new Entry(t,e,c,r,s);if(f.length>this[n]){this[a]&&this[a](t,e);return false}this[i]+=f.length;this[u].unshift(f);this[m].set(t,this[u].head);trim(this);return true}has(t){if(!this[m].has(t))return false;const e=this[m].get(t).value;return!isStale(this,e)}get(t){return get(this,t,true)}peek(t){return get(this,t,false)}pop(){const t=this[u].tail;if(!t)return null;del(this,t);return t.value}del(t){del(this,this[m].get(t))}load(t){this.reset();const e=Date.now();for(let s=t.length-1;s>=0;s--){const n=t[s];const i=n.e||0;if(0===i)this.set(n.k,n.v);else{const t=i-e;t>0&&this.set(n.k,n.v,t)}}}prune(){this[m].forEach((t,e)=>get(this,e,false))}}const get=(t,e,s)=>{const n=t[m].get(e);if(n){const e=n.value;if(isStale(t,e)){del(t,n);if(!t[r])return}else if(s){t[c]&&(n.value.now=Date.now());t[u].unshiftNode(n)}return e.value}};const isStale=(t,e)=>{if(!e||!e.maxAge&&!t[o])return false;const s=Date.now()-e.now;return e.maxAge?s>e.maxAge:t[o]&&s>t[o]};const trim=t=>{if(t[i]>t[n])for(let e=t[u].tail;t[i]>t[n]&&null!==e;){const s=e.prev;del(t,e);e=s}};const del=(t,e)=>{if(e){const s=e.value;t[a]&&t[a](s.key,s.value);t[i]-=s.length;t[m].delete(s.key);t[u].removeNode(e)}};class Entry{constructor(t,e,s,n,i){this.key=t;this.value=e;this.length=s;this.now=n;this.maxAge=i||0}}const forEachStep=(t,e,s,n)=>{let i=s.value;if(isStale(t,i)){del(t,s);t[r]||(i=void 0)}i&&e.call(n,i.value,i.key,t)};e=LRUCache;var f=e;export default f;

